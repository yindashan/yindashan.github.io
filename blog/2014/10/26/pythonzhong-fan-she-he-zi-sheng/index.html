
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Python中反射和自省 - Hello World</title>
  <meta name="author" content="yindashan">

  
  <meta name="description" content="一提到反射，总让人望而却步，感觉是一个比较高深的概念，今天抽时间重点研究了一下Python中反射的用法，特此记录。
什么是反射？简单来说，就是动态调用一个函数或者一个类对象里的函数。
什么时候用到反射呢？有时候我们会需要执行对象的某个方法，或是需要对对象的某个属性赋值， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yindashan.github.io/blog/2014/10/26/pythonzhong-fan-she-he-zi-sheng">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Hello World" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!--<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>-->
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Hello World</a></h1>
  
    <h2>The door to the world!</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:yindashan.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">我的首页</a></li>
  <li><a href="/blog/archives">文章列表</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Python中反射和自省</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-26T15:40:10+08:00" pubdate data-updated="true">Oct 26<sup>th</sup>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>一提到反射，总让人望而却步，感觉是一个比较高深的概念，今天抽时间重点研究了一下Python中反射的用法，特此记录。
什么是反射？简单来说，就是动态调用一个函数或者一个类对象里的函数。
什么时候用到反射呢？有时候我们会需要执行对象的某个方法，或是需要对对象的某个属性赋值，而方法名或者属性名在编码代码时并不能确定，需要通过参数传递字符串的形式输入。
当然，反射的内容不仅仅包含这些，还诸如获取和设置对象属性，访问对象元数据，生成器，代码，栈帧等，大家有兴趣的话可以自行查阅一下。</p>

<p>反射是个很吓唬人的名词，听起来高深莫测，在一般的编程语言里反射相对其他概念来说稍显复杂，一般来说都是作为高级主题来讲；但在Python中反射非常简单，用起来几乎感觉不到与其他的代码有区别，使用反射获取到的函数和方法可以像平常一样加上括号直接调用，获取到类后可以直接构造实例；不过获取到的字段不能直接赋值，因为拿到的其实是另一个指向同一个地方的引用，赋值只能改变当前的这个引用而已。</p>

<p>下面这位兄弟的博客，讲的很清析，可以参考一下：
<a href="http://www.cnblogs.com/huxi/archive/2011/01/02/1924317.html">http://www.cnblogs.com/huxi/archive/2011/01/02/1924317.html</a></p>

<p>首先通过一个例子来看一下本文中可能用到的对象和相关概念。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#coding: UTF-8
</span><span class='line'>import sys #  模块，sys指向这个模块对象
</span><span class='line'>import inspect
</span><span class='line'>def foo(): pass # 函数，foo指向这个函数对象
</span><span class='line'> 
</span><span class='line'>class Cat(object): # 类，Cat指向这个类对象
</span><span class='line'>    def __init__(self, name='kitty'):
</span><span class='line'>        self.name = name
</span><span class='line'>    def sayHi(self): #  实例方法，sayHi指向这个方法对象，使用类或实例.sayHi访问
</span><span class='line'>        print self.name, 'says Hi!' # 访问名为name的字段，使用实例.name访问
</span><span class='line'> 
</span><span class='line'>cat = Cat() # cat是Cat类的实例对象
</span><span class='line'> 
</span><span class='line'>print Cat.sayHi # 使用类名访问实例方法时，方法是未绑定的(unbound)
</span><span class='line'>print cat.sayHi # 使用实例访问实例方法时，方法是绑定的(bound)</span></code></pre></td></tr></table></div></figure>


<p>有时候我们会碰到这样的需求，需要执行对象的某个方法，或是需要对对象的某个字段赋值，而方法名或是字段名在编码代码时并不能确定，需要通过参数传递字符串的形式输入。举个具体的例子：当我们需要实现一个通用的DBM框架时，可能需要对数据对象的字段赋值，但我们无法预知用到这个框架的数据对象都有些什么字段，换言之，我们在写框架的时候需要通过某种机制访问未知的属性。</p>

<p>这个机制被称为反射（反过来让对象告诉我们他是什么），或是自省（让对象自己告诉我们他是什么，好吧我承认括号里是我瞎掰的- &ndash;#），用于实现在运行时获取未知对象的信息。反射是个很吓唬人的名词，听起来高深莫测，在一般的编程语言里反射相对其他概念来说稍显复杂，一般来说都是作为高级主题来讲；但在Python中反射非常简单，用起来几乎感觉不到与其他的代码有区别，使用反射获取到的函数和方法可以像平常一样加上括号直接调用，获取到类后可以直接构造实例；不过获取到的字段不能直接赋值，因为拿到的其实是另一个指向同一个地方的引用，赋值只能改变当前的这个引用而已。</p>

<h2>1. 访问对象的属性</h2>

<p>以下列出了几个内建方法，可以用来检查或是访问对象的属性。这些方法可以用于任意对象而不仅仅是例子中的Cat实例对象；Python中一切都是对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat = Cat('kitty')
</span><span class='line'> 
</span><span class='line'>print cat.name # 访问实例属性
</span><span class='line'>cat.sayHi() # 调用实例方法
</span><span class='line'> 
</span><span class='line'>print dir(cat) # 获取实例的属性名，以列表形式返回
</span><span class='line'>if hasattr(cat, 'name'): # 检查实例是否有这个属性
</span><span class='line'>    setattr(cat, 'name', 'tiger') # same as: a.name = 'tiger'
</span><span class='line'>print getattr(cat, 'name') # same as: print a.name
</span><span class='line'> 
</span><span class='line'>getattr(cat, 'sayHi')() # same as: cat.sayHi()
</span><span class='line'>dir([obj]): </span></code></pre></td></tr></table></div></figure>


<p>调用这个方法将返回包含obj大多数属性名的列表（会有一些特殊的属性不包含在内）。obj的默认值是当前的模块对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hasattr(obj, attr): </span></code></pre></td></tr></table></div></figure>


<p>这个方法用于检查obj是否有一个名为attr的值的属性，返回一个布尔值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>getattr(obj, attr): </span></code></pre></td></tr></table></div></figure>


<p>调用这个方法将返回obj中名为attr值的属性的值，例如如果attr为&#8217;bar&#8217;，则返回obj.bar。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>setattr(obj, attr, val): </span></code></pre></td></tr></table></div></figure>


<p>调用这个方法将给obj的名为attr的值的属性赋值为val。例如如果attr为&#8217;bar&#8217;，则相当于obj.bar = val。</p>

<h2>2. 访问对象的元数据</h2>

<p>当你对一个你构造的对象使用dir()时，可能会发现列表中的很多属性并不是你定义的。这些属性一般保存了对象的元数据，比如类的<strong>name</strong>属性保存了类名。大部分这些属性都可以修改，不过改动它们意义并不是很大；修改其中某些属性如function.func_code还可能导致很难发现的问题，所以改改name什么的就好了，其他的属性不要在不了解后果的情况下修改。</p>

<p>接下来列出特定对象的一些特殊属性。另外，Python的文档中有提到部分属性不一定会一直提供，下文中将以红色的星号*标记，使用前你可以先打开解释器确认一下。</p>

<h3>2.0. 准备工作：确定对象的类型</h3>

<p>在types模块中定义了全部的Python内置类型，结合内置方法isinstance()就可以确定对象的具体类型了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>isinstance(object, classinfo): </span></code></pre></td></tr></table></div></figure>


<p>检查object是不是classinfo中列举出的类型，返回布尔值。classinfo可以是一个具体的类型，也可以是多个类型的元组或列表。
types模块中仅仅定义了类型，而inspect模块中封装了很多检查类型的方法，比直接使用types模块更为轻松，所以这里不给出关于types的更多介绍，如有需要可以直接查看types模块的文档说明。本文第3节中介绍了inspect模块。</p>

<h3>2.1. 模块(module)</h3>

<p><strong>doc</strong>: 文档字符串。如果模块没有文档，这个值是None。
<em><strong>name</strong>: 始终是定义时的模块名；即使你使用import .. as 为它取了别名，或是赋值给了另一个变量名。
</em><strong>dict</strong>: 包含了模块里可用的属性名-属性的字典；也就是可以使用模块名.属性名访问的对象。
<strong>file</strong>: 包含了该模块的文件路径。需要注意的是内建的模块没有这个属性，访问它会抛出异常！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import fnmatch as m
</span><span class='line'>print m.__doc__.splitlines()[0] # Filename matching with shell patterns.
</span><span class='line'>print m.__name__                # fnmatch
</span><span class='line'>print m.__file__                # /usr/lib/python2.6/fnmatch.pyc
</span><span class='line'>print m.__dict__.items()[0]     # ('fnmatchcase', &lt;function&gt;)&lt;/function&gt;</span></code></pre></td></tr></table></div></figure>


<h3>2.2. 类(class)</h3>

<p><strong>doc</strong>: 文档字符串。如果类没有文档，这个值是None。
<em><strong>name</strong>: 始终是定义时的类名。
</em><strong>dict</strong>: 包含了类里可用的属性名-属性的字典；也就是可以使用类名.属性名访问的对象。
<strong>module</strong>: 包含该类的定义的模块名；需要注意，是字符串形式的模块名而不是模块对象。
*<strong>bases</strong>: 直接父类对象的元组；但不包含继承树更上层的其他类，比如父类的父类。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>print Cat.__doc__           # None
</span><span class='line'>print Cat.__name__          # Cat
</span><span class='line'>print Cat.__module__        # __main__
</span><span class='line'>print Cat.__bases__         # (&lt;type&gt;,)
</span><span class='line'>print Cat.__dict__          # {'__module__': '__main__', ...}&lt;/type&gt;</span></code></pre></td></tr></table></div></figure>


<h3>2.3. 实例(instance)</h3>

<p>实例是指类实例化以后的对象。</p>

<p><em><strong>dict</strong>: 包含了可用的属性名-属性字典。
</em><strong>class</strong>: 该实例的类对象。对于类Cat，cat.<strong>class</strong> == Cat 为 True。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>print cat.__dict__
</span><span class='line'>print cat.__class__
</span><span class='line'>print cat.__class__ == Cat # True</span></code></pre></td></tr></table></div></figure>


<h3>2.4. 内建函数和方法(built-in functions and methods)</h3>

<p>根据定义，内建的(built-in)模块是指使用C写的模块，可以通过sys模块的builtin_module_names字段查看都有哪些模块是内建的。这些模块中的函数和方法可以使用的属性比较少，不过一般也不需要在代码中查看它们的信息。</p>

<p><strong>doc</strong>: 函数或方法的文档。
<strong>name</strong>: 函数或方法定义时的名字。
<strong>self</strong>: 仅方法可用，如果是绑定的(bound)，则指向调用该方法的类（如果是类方法）或实例（如果是实例方法），否则为None。
*<strong>module</strong>: 函数或方法所在的模块名。</p>

<h3>2.5. 函数(function)</h3>

<p>这里特指非内建的函数。注意，在类中使用def定义的是方法，方法与函数虽然有相似的行为，但它们是不同的概念。</p>

<p><strong>doc</strong>: 函数的文档；另外也可以用属性名func_doc。
<strong>name</strong>: 函数定义时的函数名；另外也可以用属性名func_name。
<em><strong>module</strong>: 包含该函数定义的模块名；同样注意，是模块名而不是模块对象。
</em><strong>dict</strong>: 函数的可用属性；另外也可以用属性名func_dict。
不要忘了函数也是对象，可以使用函数.属性名访问属性（赋值时如果属性不存在将新增一个），或使用内置函数has/get/setattr()访问。不过，在函数中保存属性的意义并不大。
func_defaults: 这个属性保存了函数的参数默认值元组；因为默认值总是靠后的参数才有，所以不使用字典的形式也是可以与参数对应上的。
func_code: 这个属性指向一个该函数对应的code对象，code对象中定义了其他的一些特殊属性，将在下文中另外介绍。
func_globals: 这个属性指向定义函数时的全局命名空间。
*func_closure: 这个属性仅当函数是一个闭包时有效，指向一个保存了所引用到的外部函数的变量cell的元组，如果该函数不是一个内部函数，则始终为None。这个属性也是只读的。
下面的代码演示了func_closure：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#coding: UTF-8
</span><span class='line'>def foo():
</span><span class='line'>    n = 1
</span><span class='line'>    def bar():
</span><span class='line'>        print n # 引用非全局的外部变量n，构造一个闭包
</span><span class='line'>    n = 2
</span><span class='line'>    return bar
</span><span class='line'> 
</span><span class='line'>closure = foo()
</span><span class='line'>print closure.func_closure</span></code></pre></td></tr></table></div></figure>


<h1>使用dir()得知cell对象有一个cell_contents属性可以获得值</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>print closure.func_closure[0].cell_contents # 2</span></code></pre></td></tr></table></div></figure>


<p>由这个例子可以看到，遇到未知的对象使用dir()是一个很好的主意 ：）</p>

<h3>2.6. 方法(method)</h3>

<p>方法虽然不是函数，但可以理解为在函数外面加了一层外壳；拿到方法里实际的函数以后，就可以使用2.5节的属性了。</p>

<p><strong>doc</strong>: 与函数相同。
<strong>name</strong>: 与函数相同。
*<strong>module</strong>: 与函数相同。
im_func: 使用这个属性可以拿到方法里实际的函数对象的引用。另外如果是2.6以上的版本，还可以使用属性名<strong>func</strong>。
im_self: 如果是绑定的(bound)，则指向调用该方法的类（如果是类方法）或实例（如果是实例方法），否则为None。如果是2.6以上的版本，还可以使用属性名<strong>self</strong>。
im_class: 实际调用该方法的类，或实际调用该方法的实例的类。注意不是方法的定义所在的类，如果有继承关系的话。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>im = cat.sayHi
</span><span class='line'>print im.im_func
</span><span class='line'>print im.im_self # cat
</span><span class='line'>print im.im_class # Cat</span></code></pre></td></tr></table></div></figure>


<p>这里讨论的是一般的实例方法，另外还有两种特殊的方法分别是类方法(classmethod)和静态方法(staticmethod)。类方法还是方法，不过因为需要使用类名调用，所以他始终是绑定的；而静态方法可以看成是在类的命名空间里的函数（需要使用类名调用的函数），它只能使用函数的属性，不能使用方法的属性。</p>

<h3>2.7. 生成器(generator)</h3>

<p>生成器是调用一个生成器函数(generator function)返回的对象，多用于集合对象的迭代。</p>

<p><strong>iter</strong>: 仅仅是一个可迭代的标记。
gi_code: 生成器对应的code对象。
gi_frame: 生成器对应的frame对象。
gi_running: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。
next|close|send|throw: 这是几个可调用的方法，并不包含元数据信息，如何使用可以查看生成器的相关文档。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def gen():
</span><span class='line'>    for n in xrange(5):
</span><span class='line'>        yield n
</span><span class='line'>g = gen()
</span><span class='line'>print g             # &lt;generator object gen at 0x...&gt;
</span><span class='line'>print g.gi_code     # &lt;code object gen at 0x...&gt;
</span><span class='line'>print g.gi_frame    # &lt;frame object at 0x...&gt;
</span><span class='line'>print g.gi_running  # 0
</span><span class='line'>print g.next()      # 0
</span><span class='line'>print g.next()      # 1
</span><span class='line'>for n in g:
</span><span class='line'>    print n,        # 2 3 4</span></code></pre></td></tr></table></div></figure>


<p>接下来讨论的是几个不常用到的内置对象类型。这些类型在正常的编码过程中应该很少接触，除非你正在自己实现一个解释器或开发环境之类。所以这里只列出一部分属性，如果需要一份完整的属性表或想进一步了解，可以查看文末列出的参考文档。</p>

<h3>2.8. 代码块(code)</h3>

<p>代码块可以由类源代码、函数源代码或是一个简单的语句代码编译得到。这里我们只考虑它指代一个函数时的情况；2.5节中我们曾提到可以使用函数的func_code属性获取到它。code的属性全部是只读的。</p>

<p>co_argcount: 普通参数的总数，不包括<em>参数和**参数。
co_names: 所有的参数名（包括</em>参数和<strong>参数）和局部变量名的元组。
co_varnames: 所有的局部变量名的元组。
co_filename: 源代码所在的文件名。
co_flags:  这是一个数值，每一个二进制位都包含了特定信息。较关注的是0b100(0x4)和0b1000(0x8)，如果co_flags &amp; 0b100 != 0，说明使用了*args参数；如果co_flags &amp; 0b1000 != 0，说明使用了</strong>kwargs参数。另外，如果co_flags &amp; 0b100000(0x20) != 0，则说明这是一个生成器函数(generator function)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>co = cat.sayHi.func_code
</span><span class='line'>print co.co_argcount        # 1
</span><span class='line'>print co.co_names           # ('name',)
</span><span class='line'>print co.co_varnames        # ('self',)
</span><span class='line'>print co.co_flags & 0b100   # 0</span></code></pre></td></tr></table></div></figure>


<h3>2.9. 栈帧(frame)</h3>

<p>栈帧表示程序运行时函数调用栈中的某一帧。函数没有属性可以获取它，因为它在函数调用时才会产生，而生成器则是由函数调用返回的，所以有属性指向栈帧。想要获得某个函数相关的栈帧，则必须在调用这个函数且这个函数尚未返回时获取。你可以使用sys模块的_getframe()函数、或inspect模块的currentframe()函数获取当前栈帧。这里列出来的属性全部是只读的。</p>

<p>f_back: 调用栈的前一帧。
f_code: 栈帧对应的code对象。
f_locals: 用在当前栈帧时与内建函数locals()相同，但你可以先获取其他帧然后使用这个属性获取那个帧的locals()。
f_globals: 用在当前栈帧时与内建函数globals()相同，但你可以先获取其他帧……。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def add(x, y=1):
</span><span class='line'>    f = inspect.currentframe()
</span><span class='line'>    print f.f_locals    # same as locals()
</span><span class='line'>    print f.f_back      # &lt;frame object at 0x...&gt;
</span><span class='line'>    return x+y
</span><span class='line'>add(2)</span></code></pre></td></tr></table></div></figure>


<h3>2.10. 追踪(traceback)</h3>

<p>追踪是在出现异常时用于回溯的对象，与栈帧相反。由于异常时才会构建，而异常未捕获时会一直向外层栈帧抛出，所以需要使用try才能见到这个对象。你可以使用sys模块的exc_info()函数获得它，这个函数返回一个元组，元素分别是异常类型、异常对象、追踪。traceback的属性全部是只读的。</p>

<p>tb_next: 追踪的下一个追踪对象。
tb_frame: 当前追踪对应的栈帧。
tb_lineno: 当前追踪的行号。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def div(x, y):
</span><span class='line'>    try:
</span><span class='line'>        return x/y
</span><span class='line'>    except:
</span><span class='line'>        tb = sys.exc_info()[2]  # return (exc_type, exc_value, traceback)
</span><span class='line'>        print tb
</span><span class='line'>        print tb.tb_lineno      # "return x/y" 的行号
</span><span class='line'>div(1, 0)</span></code></pre></td></tr></table></div></figure>


<h2>3. 使用inspect模块</h2>

<p>inspect模块提供了一系列函数用于帮助使用自省。下面仅列出较常用的一些函数，想获得全部的函数资料可以查看inspect模块的文档。</p>

<h3>3.1. 检查对象类型</h3>

<p>is{module|class|function|method|builtin}(obj):
检查对象是否为模块、类、函数、方法、内建函数或方法。
isroutine(obj):
用于检查对象是否为函数、方法、内建函数或方法等等可调用类型。用这个方法会比多个is<em>()更方便，不过它的实现仍然是用了多个is</em>()。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>im = cat.sayHi
</span><span class='line'>if inspect.isroutine(im):
</span><span class='line'>    im()</span></code></pre></td></tr></table></div></figure>


<p>对于实现了<strong>call</strong>的类实例，这个方法会返回False。如果目的是只要可以直接调用就需要是True的话，不妨使用isinstance(obj, collections.Callable)这种形式。我也不知道为什么Callable会在collections模块中，抱歉！我猜大概是因为collections模块中包含了很多其他的ABC(Abstract Base Class)的缘故吧：）</p>

<h3>3.2. 获取对象信息</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>getmembers(object[, predicate]): </span></code></pre></td></tr></table></div></figure>


<p>这个方法是dir()的扩展版，它会将dir()找到的名字对应的属性一并返回，形如[(name, value), &hellip;]。另外，predicate是一个方法的引用，如果指定，则应当接受value作为参数并返回一个布尔值，如果为False，相应的属性将不会返回。使用is*作为第二个参数可以过滤出指定类型的属性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>getmodule(object): </span></code></pre></td></tr></table></div></figure>


<p>还在为第2节中的<strong>module</strong>属性只返回字符串而遗憾吗？这个方法一定可以满足你，它返回object的定义所在的模块对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>get{file|sourcefile}(object): </span></code></pre></td></tr></table></div></figure>


<p>获取object的定义所在的模块的文件名|源代码文件名（如果没有则返回None）。用于内建的对象（内建模块、类、函数、方法）上时会抛出TypeError异常。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>get{source|sourcelines}(object): </span></code></pre></td></tr></table></div></figure>


<p>获取object的定义的源代码，以字符串|字符串列表返回。代码无法访问时会抛出IOError异常。只能用于module/class/function/method/code/frame/traceack对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>getargspec(func): </span></code></pre></td></tr></table></div></figure>


<p>仅用于方法，获取方法声明的参数，返回元组，分别是(普通参数名的列表, *参数名, **参数名, 默认值元组)。如果没有值，将是空列表和3个None。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def add(x, y=1, *z):
</span><span class='line'>    return x + y + sum(z)
</span><span class='line'>print inspect.getargspec(add)
</span><span class='line'>#ArgSpec(args=['x', 'y'], varargs='z', keywords=None, defaults=(1,))
</span><span class='line'>getargvalues(frame): </span></code></pre></td></tr></table></div></figure>


<p>仅用于栈帧，获取栈帧中保存的该次函数调用的参数值，返回元组，分别是(普通参数名的列表, *参数名, **参数名, 帧的locals())。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def add(x, y=1, *z):
</span><span class='line'>    print inspect.getargvalues(inspect.currentframe())
</span><span class='line'>    return x + y + sum(z)
</span><span class='line'>add(2)
</span><span class='line'>#ArgInfo(args=['x', 'y'], varargs='z', keywords=None, locals={'y': 1, 'x': 2, 'z': ()})
</span><span class='line'>getcallargs(func[, *args][, **kwds]): </span></code></pre></td></tr></table></div></figure>


<p>返回使用args和kwds调用该方法时各参数对应的值的字典。这个方法仅在2.7版本中才有。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>getmro(cls): </span></code></pre></td></tr></table></div></figure>


<p>返回一个类型元组，查找类属性时按照这个元组中的顺序。如果是新式类，与cls.<strong>mro</strong>结果一样。但旧式类没有<strong>mro</strong>这个属性，直接使用这个属性会报异常，所以这个方法还是有它的价值的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>print inspect.getmro(Cat)
</span><span class='line'>#(&lt;class '__main__.Cat'&gt;, &lt;type 'object'&gt;)
</span><span class='line'>print Cat.__mro__
</span><span class='line'>#(&lt;class '__main__.Cat'&gt;, &lt;type 'object'&gt;)
</span><span class='line'>class Dog: pass
</span><span class='line'>print inspect.getmro(Dog)
</span><span class='line'>#(&lt;class __main__.Dog at 0x...&gt;,)
</span><span class='line'>print Dog.__mro__ # AttributeError
</span><span class='line'>currentframe(): </span></code></pre></td></tr></table></div></figure>


<p>返回当前的栈帧对象。
其他的操作frame和traceback的函数请查阅inspect模块的文档，用的比较少，这里就不多介绍了。</p>

<h2>4. 本地测试代码</h2>

<h3>4.1. 简单用法</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/usr/bin/env python
</span><span class='line'>#coding: utf-8
</span><span class='line'>'''
</span><span class='line'>python中的反射
</span><span class='line'>说起反射，大家应该都不陌生吧，特别是熟悉Java的程序员，一定经常和 Class.forName 打交道。
</span><span class='line'>Java的众多框架中，如 Spring ， eclipse plugin 机制等很多都依赖于Java的反射技术。
</span><span class='line'>感觉反射在Java中属于比较高级的技术，通常作为高级主题来讲述。
</span><span class='line'>但是在Python中反射比java中简单得多。 使用反射获取到的函数和方法可以像平常一样加上括号直接调用，获取到类后可以直接构造实例。
</span><span class='line'>&gt;&gt;&gt; import json
</span><span class='line'>&gt;&gt;&gt; methodList = [attr for attr in dir(json)  if callable(getattr(json,attr))] 
</span><span class='line'>&gt;&gt;&gt; methodList
</span><span class='line'>['JSONDecoder', 'JSONEncoder', 'dump', 'dumps', 'load', 'loads']
</span><span class='line'>&gt;&gt;&gt;
</span><span class='line'>'''
</span><span class='line'>import sys #  模块，sys指向这个模块对象
</span><span class='line'>import inspect
</span><span class='line'>def foo(): pass # 函数，foo指向这个函数对象
</span><span class='line'>
</span><span class='line'>class Cat(object): # 类，Cat指向这个类对象
</span><span class='line'>    def __init__(self, name='kitty'):
</span><span class='line'>        self.name = name
</span><span class='line'>        
</span><span class='line'>    def echo_methods(self):
</span><span class='line'>        """ 输出类中所有的方法，以及doc 文档 """
</span><span class='line'>        print "\n Method List: "
</span><span class='line'>        for item_method in dir(self):
</span><span class='line'>            attr = getattr(self, item_method)
</span><span class='line'>            if callable(attr):
</span><span class='line'>                print item_method,"():",attr.__doc__
</span><span class='line'> 
</span><span class='line'>    def echo_attributes(self):
</span><span class='line'>        print "\n Attributes"
</span><span class='line'>        for item_attr in dir(self):
</span><span class='line'>            attr = getattr(self, item_attr)
</span><span class='line'>            if not callable(attr):
</span><span class='line'>                print item_attr,":",attr
</span><span class='line'>                
</span><span class='line'>    def sayHi(self): #  实例方法，sayHi指向这个方法对象，使用类或实例.sayHi访问
</span><span class='line'>        print self.name, 'says Hi!' # 访问名为name的字段，使用实例.name访问
</span><span class='line'>        
</span><span class='line'>    def print_name(self, name):
</span><span class='line'>        self.name = name
</span><span class='line'>        print self.name, 'print_name!'
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>def main():
</span><span class='line'>    cat = Cat() # cat是Cat类的实例对象
</span><span class='line'>    print Cat.sayHi # 使用类名访问实例方法时，方法是未绑定的(unbound)
</span><span class='line'>    print cat.sayHi # 使用实例访问实例方法时，方法是绑定的(bound)
</span><span class='line'>    
</span><span class='line'>    cat.echo_attributes()
</span><span class='line'>    cat.echo_methods()
</span><span class='line'>    
</span><span class='line'>    cat = Cat('kitty')
</span><span class='line'>    print cat.name # 访问实例属性
</span><span class='line'>    cat.sayHi() # 调用实例方法
</span><span class='line'>    
</span><span class='line'>    print dir(cat) # 获取实例的属性名，以列表形式返回
</span><span class='line'>    if hasattr(cat, 'name'): # 检查实例是否有这个属性
</span><span class='line'>        setattr(cat, 'name', 'tiger') # same as: a.name = 'tiger'
</span><span class='line'>    print getattr(cat, 'name') # same as: print a.name
</span><span class='line'>    
</span><span class='line'>    getattr(cat, 'sayHi')() # same as: cat.sayHi()
</span><span class='line'>    
</span><span class='line'>#    for item in dir(cat):
</span><span class='line'>#        if not item.startswith("__") and callable(getattr(cat, item)): # callable检查属性是否是可以调用的函数 
</span><span class='line'>#            func = getattr(cat, item)
</span><span class='line'>#            func() # 调用函数
</span><span class='line'>    
</span><span class='line'>    func = getattr(cat, "print_name")
</span><span class='line'>    if callable(func):
</span><span class='line'>        func('hello')
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>if __name__ == "__main__":
</span><span class='line'>    main()</span></code></pre></td></tr></table></div></figure>


<h3>4.2. 稍微复杂点的用法</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># -*- coding: UTF-8 -*-
</span><span class='line'>
</span><span class='line'>'''
</span><span class='line'>python中反射用法
</span><span class='line'>'''
</span><span class='line'>
</span><span class='line'>import inspect
</span><span class='line'>import re
</span><span class='line'>
</span><span class='line'>#===============================================================================
</span><span class='line'># 测试
</span><span class='line'>#===============================================================================
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>def _unittest(func, *cases):
</span><span class='line'>    for case in cases:
</span><span class='line'>        _functest(func, *case)
</span><span class='line'>        
</span><span class='line'>
</span><span class='line'>def _functest(func, isCkPass, *args, **kws):
</span><span class='line'>    try:
</span><span class='line'>        print 'isCkPass = ', isCkPass
</span><span class='line'>        func(*args, **kws)
</span><span class='line'>    except Exception as e:
</span><span class='line'>        print e
</span><span class='line'>
</span><span class='line'>def _test1_simple():
</span><span class='line'>    def foo1(i): print 'i=', i
</span><span class='line'>    _unittest(foo1, 
</span><span class='line'>              (True, 1), 
</span><span class='line'>              (False, 's'), 
</span><span class='line'>              (False, None))
</span><span class='line'>
</span><span class='line'>    def foo2(s, x): pass
</span><span class='line'>    _unittest(foo2, 
</span><span class='line'>              (True, 1, 2), 
</span><span class='line'>              (False, 's', 's'))
</span><span class='line'>    
</span><span class='line'>    def foo7(s, **kws): pass
</span><span class='line'>    _functest(foo7, True, s='a', a=1, b=2)
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>def _main():
</span><span class='line'>    d = globals()
</span><span class='line'>    from types import FunctionType
</span><span class='line'>    print
</span><span class='line'>    for f in d:
</span><span class='line'>        if f.startswith('_test'):
</span><span class='line'>            f = d[f]
</span><span class='line'>            if isinstance(f, FunctionType):
</span><span class='line'>                f()
</span><span class='line'>
</span><span class='line'>if __name__ == '__main__':
</span><span class='line'>    _main()
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>



</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">yindashan</span></span>

      








  


<time datetime="2014-10-26T15:40:10+08:00" pubdate data-updated="true">Oct 26<sup>th</sup>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/python/'>python</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
  
    <!-- JiaThis Button BEGIN -->
<div class="jiathis_style_32x32">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1395155901683607" charset="utf-8"></script>
<!-- JiaThis Button END -->
<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js"></script>
<!-- UY END -->
 
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/10/25/pythonzhong-json-pickle-cpicklezai-xu-lie-hua-shi-de-dui-bi/" title="Previous Post: Python中json_pickle_cPickle在序列化时的性能对比">&laquo; Python中json_pickle_cPickle在序列化时的性能对比</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/10/27/pythonzhong-dai-ma-feng-ge-de-gai-bian-he-xiang-ying-de-xing-neng-you-hua/" title="Next Post: Python中代码风格的改变和相应的性能优化">Python中代码风格的改变和相应的性能优化 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>文章类别</h1>
    <ul id="category-list"><li><a href='/blog/categories/octopress'>octopress (2)</a></li><li><a href='/blog/categories/python'>python (4)</a></li><li><a href='/blog/categories/ce-shi'>测试 (3)</a></li><li><a href='/blog/categories/sheng-huo'>生活 (1)</a></li></ul>
</section>
<section>
    <h1>标签云</h1>
    <ul class="tag-cloud">
        <a style="font-size: 100%" href="/tags/github/">Github</a>
<a style="font-size: 100%" href="/tags/linux/">Linux</a>
<a style="font-size: 100%" href="/tags/thinking/">Thinking</a>
<a style="font-size: 100%" href="/tags/jekyll/">jekyll</a>
<a style="font-size: 100%" href="/tags/tag-test/">tag_test</a>
<a style="font-size: 210%" href="/tags/test/">test</a>

    </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/10/27/pythonzhong-dai-ma-feng-ge-de-gai-bian-he-xiang-ying-de-xing-neng-you-hua/">Python中代码风格的改变和相应的性能优化</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/26/pythonzhong-fan-she-he-zi-sheng/">Python中反射和自省</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/25/pythonzhong-json-pickle-cpicklezai-xu-lie-hua-shi-de-dui-bi/">Python中json_pickle_cPickle在序列化时的性能对比</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/24/pythonzhong-zhuang-shi-qi-xiang-jie/">Python中装饰器详解</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/22/qian-li-zhi-xing-,shi-yu-zu-xia/">千里之行，始于足下</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/yindashan">@yindashan</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'yindashan',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - yindashan -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
