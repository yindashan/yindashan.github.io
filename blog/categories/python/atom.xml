<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Hello World]]></title>
  <link href="http://yindashan.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://yindashan.github.io/"/>
  <updated>2014-10-27T11:08:29+08:00</updated>
  <id>http://yindashan.github.io/</id>
  <author>
    <name><![CDATA[yindashan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python中代码风格的改变和相应的性能优化]]></title>
    <link href="http://yindashan.github.io/blog/2014/10/27/pythonzhong-dai-ma-feng-ge-de-gai-bian-he-xiang-ying-de-xing-neng-you-hua/"/>
    <updated>2014-10-27T09:58:32+08:00</updated>
    <id>http://yindashan.github.io/blog/2014/10/27/pythonzhong-dai-ma-feng-ge-de-gai-bian-he-xiang-ying-de-xing-neng-you-hua</id>
    <content type="html"><![CDATA[<h2>使用现代风格改善你的代码</h2>

<p>原文： <a href="http://python3porting.com/improving.html">http://python3porting.com/improving.html</a><br>
译者： TheLover_Z<br>
转自： <a href="http://pycoders-weekly-chinese.readthedocs.org/en/latest/issue13/improving-your-code-with-modern-idioms.html">http://pycoders-weekly-chinese.readthedocs.org/en/latest/issue13/improving-your-code-with-modern-idioms.html</a></p>

<p>一旦你开始使用 Python 3，你就有机会接触新的特性来改善你的代码。这篇文章中提到的很多东西实际上在 Python 3 之前就已经被支持了。但我还是要提一下它们，因为知道了这些以后你的代码可以从中获益。我说的包括修饰器，在 Python 2.2 开始提供支持； sorted() 方法，在 Python 2.4 开始提供支持；还有上下文管理，在 Python 2.5 开始提供支持。</p>

<p>这里提及的其它新特性在 Python 2.6 或者 2.7 都提供了支持，所以说如果你不是在用 Python 2.5 和之前的版本的话，你可以使用这里提到的几乎全部的新特性。</p>

<h3>使用 sorted() 来替代 .sort()</h3>

<p>在 Python 中，列表有一个 .sort() 方法可以进行排序。 .sort() 会影响列表的结构。下面这么写是因为在 Python 2.3 之前只能这么写。
```</p>

<blockquote><blockquote><blockquote><p>infile = open(&lsquo;pythons.txt&rsquo;)
pythons = infile.readlines()
pythons.sort()
[x.strip() for x in pythons]
[&lsquo;Eric&rsquo;, &lsquo;Graham&rsquo;, &lsquo;John&rsquo;, &lsquo;Michael&rsquo;, &lsquo;Terry&rsquo;, &lsquo;Terry&rsquo;]
<code>
Python 2.4 开始加入了新的支持 sorted() ，它会返回一个排好序的列表并且接受和 .sort() 一样的参数。使用 sorted() 你可以避免改变列表的结构。它还可以接受迭代器作为输入而不只是列表，这样可以让你的代码看起来更棒。
</code>
infile = open(&lsquo;pythons.txt&rsquo;)
[x.strip() for x in sorted(infile)]
[&lsquo;Eric&rsquo;, &lsquo;Graham&rsquo;, &lsquo;John&rsquo;, &lsquo;Michael&rsquo;, &lsquo;Terry&rsquo;, &lsquo;Terry&rsquo;]
```
然而，如果你把 mylist.sort() 替换为 mylist = sorted(mylist) 是没有用的，而且还会消耗更多的内存。</p></blockquote></blockquote></blockquote>

<p>2to3 有时会把 .sort() 改为 sorted() 。</p>

<h3>使用上下文管理器来编写代码</h3>

<p>从 Python 2.5 开始你可以使用上下文管理器，它允许你创造和管理运行时内容。如果你觉得听起来有点儿抽象，那就对了。上下文管理器确实很抽象并且很灵活，很容易被误用，我这就教你怎么正确运用它。</p>

<p>上下文管理器被用来当作 with 的一部分，在 with 的代码块内都有效。在代码块结束的时候上下文管理器退出。这可能听起来不是那么令人激动，除非我告诉你你可以使用它来实现资源分配。你进入上下文的时候资源管理器分配资源，你退出的时候它释放资源。</p>

<p>with 语句</p>

<p>with 语句是被设计用来简化“try / finally”语句的。通常的用处在于共享资源的获取和释放，比如文件、数据库和线程资源。它的用法如下：
```
with context_exp [as var]:</p>

<pre><code>    with_suit
</code></pre>

<p>```
with 语句也是复合语句的一种，就像 if、try 一样，它的后面也有个“：”，并且紧跟一个缩进的代码块 with_suit。context_exp 表达式的作用是提供一个上下文管理器（Context Manager），整个 with_suit 代码块都是在这个上下文管理器的运行环境下执行的。context_exp 可以直接是一个上下文管理器的引用，也可以是一句可执行的表达式，with 语句会自动执行这个表达式以获得上下文管理对象。with 语句的实际执行流程是这样的：</p>

<p>1.执行 context_exp 以获取上下文管理器<br>
2.加载上下文管理器的 <strong>exit</strong>() 方法以备稍后调用<br>
3.调用上下文管理器的 <strong>enter</strong>() 方法<br>
4.如果有 as var 从句，则将 <strong>enter</strong>() 方法的返回值赋给 var<br>
5.执行子代码块 with_suit<br>
6.调用上下文管理器的 <strong>exit</strong>() 方法，如果 with_suit 的退出是由异常引发的，那么该异常的 type、value 和 traceback 会作为参数传给 <strong>exit</strong>()，否则传三个 None<br>
7.如果 with_suit 的退出由异常引发，并且 <strong>exit</strong>() 的返回值等于 False，那么这个异常将被重新引发一次；如果 <strong>exit</strong>() 的返回值等于True，那么这个异常就被无视掉，继续执行后面的代码<br></p>

<p>即，可以把 <strong>exit</strong>() 方法看成是“try / finally”的 finally，它总是会被自动调用。Python 里已经有了一些支持上下文管理协议的对象，比如文件对象，在使用 with 语句处理文件对象时，可以不再关心“打开的文件必须记得要关闭”这个问题了：</p>

<p>```</p>

<blockquote><blockquote><blockquote><p>with open(&lsquo;test.py&rsquo;) as f:</p>

<pre><code>print(f.readline())
</code></pre></blockquote></blockquote></blockquote>

<h1>!/usr/bin/env python</h1>

<blockquote><blockquote><blockquote><p>f.readline()
Traceback (most recent call last):
  File &ldquo;&lt;pyshell#3>&rdquo;, line 1, in <module></p>

<pre><code>f.readline()
</code></pre>

<p>ValueError: I/O operation on closed file.
```
可以看到在 with 语句完成后，f 已经自动关闭了，这个过程就是在 f 的<strong>exit</strong>() 方法里完成的。然后下面再来详细介绍一下上下文管理器：</p></blockquote></blockquote></blockquote>

<p>最常用的例子是读写文件。在大多数的更面向底层的语言中你必须记得关闭已打开的文件，但在 Python 中你不需要这么做。然而有时候你必须确认你关掉了文件，比如说你在循环中打开了许多文件以至于你用完了文件名。
```</p>

<blockquote><blockquote><blockquote><p>f = open(&lsquo;/tmp/afile.txt&rsquo;, &lsquo;w&rsquo;)
try:
&hellip;     n = f.write(&lsquo;sometext&rsquo;)
&hellip; finally:
&hellip;     f.close()
<code>
你也可以这么写，使用上下文管理器。
</code>
with open(&lsquo;/tmp/afile.txt&rsquo;, &lsquo;w&rsquo;) as f:
&hellip;     n = f.write(&lsquo;sometext&rsquo;)
```
当你使用上下文管理器的时候，代码块结束的时候文件就会自动关闭，就算是有错误发生也是这样。正如你所看到的那样，代码量少了很多，但是更重要的是程序看起来干净多了，也易读了。</p></blockquote></blockquote></blockquote>

<p>另一个例子是如果你想要重定向标准输出。正如前面一样，你会使用 try/except 。那样也不错，如果你只使用一次的话。但是如果你有很多次这样的需求的话，上下文管理器是你不二的选择。
```</p>

<blockquote><blockquote><blockquote><p>import sys
from StringIO import StringIO
class redirect_stdout:
&hellip;     def <strong>init</strong>(self, target):
&hellip;         self.stdout = sys.stdout
&hellip;         self.target = target
&hellip;
&hellip;     def <strong>enter</strong>(self):
&hellip;         sys.stdout = self.target
&hellip;
&hellip;     def <strong>exit</strong>(self, type, value, tb):
&hellip;         sys.stdout = self.stdout
&hellip;
out = StringIO()
with redirect_stdout(out):
&hellip;     print &lsquo;Test&rsquo;
&hellip;
out.getvalue() == &lsquo;Test\n&rsquo;
True
```
碰到 with 语句以后 <strong>enter</strong> 方法被调用，退出的时候 <strong>exit</strong>() 被调用，包括引发错误。</p></blockquote></blockquote></blockquote>

<p>上下文管理器在很多地方都可以使用。你的任何使用例外的代码最好确保资源或者全局变量没有被分配或者设置。</p>

<p>contextlib 库有各种各样的函数帮助你使用上下文管理器。比如说，如果你有一个有 .close() 方法但不是上下文管理器的对象，你可以使用 closing() 函数来在 with 块结束的时候自动关闭它们。
```</p>

<blockquote><blockquote><blockquote><p>from contextlib import closing
import urllib</p>

<p>book_url = &lsquo;<a href="http://python3porting.com/">http://python3porting.com/</a>&rsquo;
with closing(urllib.urlopen(book_url)) as page:
&hellip;     print len(page.readlines())
117
```</p>

<h3>高级字符串格式化</h3>

<p>在 Python 3 和 2.6 中，一种新的字符串格式支持被引进了。它更灵活并且有更聪明的语法。</p></blockquote></blockquote></blockquote>

<p>旧的字符串格式：
```</p>

<blockquote><blockquote><blockquote><p>&lsquo;I %s Python %i&rsquo; % (&lsquo;like&rsquo;, 2)
&lsquo;I like Python 2&rsquo;
<code>
新的字符串格式：
</code>
&lsquo;I {0} Python {1}&rsquo;.format(&lsquo;♥&rsquo;, 3)
&lsquo;I ♥ Python 3&rsquo;
<code>
使用这些新特性你可以实现一些比较疯狂的小东西，但是玩过火的话你旧失去了它易读的优点：
</code>
import sys
&lsquo;Python {0.version_info[0]:!&lt;9.1%}&rsquo;.format(sys)
&lsquo;Python 300.0%!!!&rsquo;
```
更详细的文档请参考 Common String Operations 。</p></blockquote></blockquote></blockquote>

<p>旧的字符串格式基于 % 的这个特性可能最终会被移除，不过最终日期还没有定。</p>

<h3>类修饰器</h3>

<p>修饰器在 Python 2.4 的时候被支持，然后有了内置的修饰器比如说 @property 和 @classmethod ，修饰器开始变的流行。Python 2.6 引入了类修饰器。</p>

<p>类修饰器可以用来包裹类或者修饰类。一个例子就是 functools.total_ordering ，可以让你实现最小的富比较操作符，然后增加到你的类。它们可以作为元类，类修饰器的例子就是修饰器可以把类变成一个单独的类。 zope.interface 类修饰器可以注册一个作为特定接口的类。</p>

<h3>集合</h3>

<p>Python 3 中引入了一种新的集合语法。相对于 set([1, 2, 3]) 你可以使用更干净语法的 {1, 2, 3} 。两种语法在 Python 3 中都可以工作，但是更建议使用新的语法。
```</p>

<blockquote><blockquote><blockquote><p>set([1,2,3])
{1, 2, 3}
```</p>

<h3>yield 和 生成器</h3>

<p>就像浮点除法操作符和 .sort() 的 key 参数，生成器已经在不知不觉深入了我们的编码生活。虽然不多见，但它们还是非常实用的，可以帮你节省内存，简化代码。我们来看看这个例子：
<code>
def allcombinations(starters, endings):
...    result = []
...    for s in starters:
...         for e in endings:
...             result.append(s+e)
...     return result
</code>
这么写就优雅多了：
<code>
def allcombinations(starters, endings):
...     for s in starters:
...         for e in endings:
...             yield s+e
</code>
生成器在 Python 2.2 开始加入支持，但是 Python 2.4 进行了一些改进。看起来很像是列表表达式，但并不返回列表而是返回表达式。它们在有列表表达式的地方几乎都可以使用。
<code>
sum([x*x for x in xrange(2000000)])
2666664666667000000L
</code>
可以写作：
<code>
sum(x*x for x in xrange(2000000))
2666664666667000000L
</code></p>

<h3>更多的推导式</h3>

<p>在 Python 3 和 2.6 中，生成器推导式被引进。它就是简单的一个带括号的生成器表达式，可以和列表推导式一样工作，返回一个生成器而不是列表。
<code>
(x for x in 'Silly Walk')
&lt;generator object &lt;genexpr&gt; at ...&gt;
</code>
在 Python 3 中生成器推导式不仅仅是一个新的漂亮的特性，而是一个重要的改变，因为生成器推导式现在是其它所有内置推导式的基础。在 Python 3 中列表推导式只是一个给 list 类型的构造器提供生成器表达式的语法糖。
```
list(x for x in &lsquo;Silly Walk&rsquo;)
[&rsquo;S', &lsquo;i&rsquo;, &lsquo;l&rsquo;, &lsquo;l&rsquo;, &lsquo;y&rsquo;, &lsquo; &rsquo;, &lsquo;W&rsquo;, &lsquo;a&rsquo;, &lsquo;l&rsquo;, &lsquo;k&rsquo;]</p>

<p>[x for x in &lsquo;Silly Walk&rsquo;]
[&rsquo;S', &lsquo;i&rsquo;, &lsquo;l&rsquo;, &lsquo;l&rsquo;, &lsquo;y&rsquo;, &lsquo; &rsquo;, &lsquo;W&rsquo;, &lsquo;a&rsquo;, &lsquo;l&rsquo;, &lsquo;k&rsquo;]
```
这也意味着循环变量再也不会掺入附近的命名空间了。</p></blockquote></blockquote></blockquote>

<p>生成器推导式也可以用 Python 2.6 及其以后版本的 dict() 和 set() 构造器生成。但是在 Python 3 还有 Python 2.7 中，你可以用新的语法来定义字典和列表推导式：
```</p>

<blockquote><blockquote><blockquote><p>department = &lsquo;Silly Walk&rsquo;
{x: department.count(x) for x in department}
{&lsquo;a&rsquo;: 1, &lsquo; &rsquo;: 1, &lsquo;i&rsquo;: 1, &lsquo;k&rsquo;: 1, &lsquo;l&rsquo;: 3, &rsquo;S': 1, &lsquo;W&rsquo;: 1, &lsquo;y&rsquo;: 1}</p>

<p>{x for x in department}
{&lsquo;a&rsquo;, &lsquo; &rsquo;, &lsquo;i&rsquo;, &lsquo;k&rsquo;, &lsquo;l&rsquo;, &rsquo;S', &lsquo;W&rsquo;, &lsquo;y&rsquo;}
```</p>

<h3>新的模块</h3>

<p>还有许多新的模块值得你一看。在这里我就不多说了，因为大多数如果你不重写软件的话可能获益不多，但你应该知道它们存在。你可以翻看一下 Python 文档来了解一下。</p></blockquote></blockquote></blockquote>

<p>abc</p>

<p>abc 模块包含了对生成抽象的基础类的支持，你可以 标记 一个基础类的方法或者属性为“抽象”，意思是你必须在子类中进行实现，否则无法实例化。</p>

<p>抽象基础类也可以创建没有实体方法的类，用于定义接口。</p>

<p>abc 模块在 Python 2.6 及其以后的版本被支持。</p>

<p>multiprocessing 和 future</p>

<p>multiprocessing 是一个新的模块，用于进行多进程操作，它允许你拥有进程队列和使用锁，还有用于同步进程的 信号标 。</p>

<p>multiprocessing 在 Python 2.6 以后被加入支持。在 2.4 和 2.5 你可以使用 CheeseShop 。</p>

<p>如果你要做并发你可以看一下 future 模块，在 Python 3.2 引入了这个模块，在 Python 2.5 及以后的版本可以用 参考这里 。</p>

<p>numbers 和 fractions</p>

<p>Python 3 加入了这个库。大多数情况下你不会注意到它，但是很有趣的是 fractions 模块，在 Python 2.6 被支持。
```</p>

<blockquote><blockquote><blockquote><p>from fractions import Fraction
Fraction(3,4) / Fraction(&lsquo;2/3&rsquo;)
Fraction(9, 8)
```
还有 numbers 模块，包含支持所有数字类型的抽象基础类。如果你正在实现你自己的数字类型的话，那么它非常有用。</p></blockquote></blockquote></blockquote>

<p>中英文对照
生成器推导式 &ndash; generator comprehension</p>

<p>列表推导式 － list comprehension</p>

<p>生成器 － generator</p>

<p>抽象的基础类 － abstract base classes</p>

<h2>Python性能优化的20条建议</h2>

<p>转自：<a href="http://segmentfault.com/blog/defool/1190000000666603">http://segmentfault.com/blog/defool/1190000000666603</a></p>

<h3>1.优化算法时间复杂度</h3>

<p>算法的时间复杂度对程序的执行效率影响最大，在Python中可以通过选择合适的数据结构来优化时间复杂度，如list和set查找某一个元素的时间复杂度分别是O(n)和O(1)。不同的场景有不同的优化方式，总得来说，一般有分治，分支界限，贪心，动态规划等思想。</p>

<h3>2.减少冗余数据</h3>

<p>如用上三角或下三角的方式去保存一个大的对称矩阵。在0元素占大多数的矩阵里使用稀疏矩阵表示。</p>

<h3>3.合理使用copy与deepcopy</h3>

<p>对于dict和list等数据结构的对象，直接赋值使用的是引用的方式。而有些情况下需要复制整个对象，这时可以使用copy包里的copy和deepcopy，这两个函数的不同之处在于后者是递归复制的。效率也不一样：（以下程序在ipython中运行）
<code>
import copy
a = range(100000)
%timeit -n 10 copy.copy(a) # 运行10次 copy.copy(a)
%timeit -n 10 copy.deepcopy(a)
10 loops, best of 3: 1.55 ms per loop
10 loops, best of 3: 151 ms per loop
</code>
timeit后面的-n表示运行的次数，后两行对应的是两个timeit的输出，下同。由此可见后者慢一个数量级。</p>

<h3>4.使用dict或set查找元素</h3>

<p>python dict和set都是使用hash表来实现(类似c++11标准库中unordered_map)，查找元素的时间复杂度是O(1)
<code>
a = range(1000)
s = set(a)
d = dict((i,1) for i in a)
%timeit -n 10000 100 in d
%timeit -n 10000 100 in s
10000 loops, best of 3: 43.5 ns per loop
10000 loops, best of 3: 49.6 ns per loop
</code>
dict的效率略高(占用的空间也多一些)。</p>

<h3>5.合理使用生成器（generator）和yield</h3>

<p><code>
%timeit -n 100 a = (i for i in range(100000))
%timeit -n 100 b = [i for i in range(100000)]
100 loops, best of 3: 1.54 ms per loop
100 loops, best of 3: 4.56 ms per loop
</code>
使用()得到的是一个generator对象，所需要的内存空间与列表的大小无关，所以效率会高一些。在具体应用上，比如set(i for i in range(100000))会比set([i for i in range(100000)])快。</p>

<p>但是对于需要循环遍历的情况：
<code>
%timeit -n 10 for x in (i for i in range(100000)): pass
%timeit -n 10 for x in [i for i in range(100000)]: pass
10 loops, best of 3: 6.51 ms per loop
10 loops, best of 3: 5.54 ms per loop
</code>
后者的效率反而更高，但是如果循环里有break,用generator的好处是显而易见的。yield也是用于创建generator：
```
def yield_func(ls):</p>

<pre><code>for i in ls:
    yield i+1
</code></pre>

<p>def not_yield_func(ls):</p>

<pre><code>return [i+1 for i in ls]
</code></pre>

<p>ls = range(1000000)
%timeit -n 10 for i in yield_func(ls):pass
%timeit -n 10 for i in not_yield_func(ls):pass
10 loops, best of 3: 63.8 ms per loop
10 loops, best of 3: 62.9 ms per loop
```
对于内存不是非常大的list，可以直接返回一个list，但是可读性yield更佳(人个喜好)。</p>

<p>python2.x内置generator功能的有xrange函数、itertools包等。</p>

<h3>6.优化循环</h3>

<p>循环之外能做的事不要放在循环内，比如下面的优化可以快一倍：
<code>
a = range(10000)
size_a = len(a)
%timeit -n 1000 for i in a: k = len(a)
%timeit -n 1000 for i in a: k = size_a
1000 loops, best of 3: 569 µs per loop
1000 loops, best of 3: 256 µs per loop
</code></p>

<h3>7.优化包含多个判断表达式的顺序</h3>

<p>对于and，应该把满足条件少的放在前面，对于or，把满足条件多的放在前面。如：
<code>
a = range(2000)  
%timeit -n 100 [i for i in a if 10 &lt; i &lt; 20 or 1000 &lt; i &lt; 2000]
%timeit -n 100 [i for i in a if 1000 &lt; i &lt; 2000 or 100 &lt; i &lt; 20]     
%timeit -n 100 [i for i in a if i % 2 == 0 and i &gt; 1900]
%timeit -n 100 [i for i in a if i &gt; 1900 and i % 2 == 0]
100 loops, best of 3: 287 µs per loop
100 loops, best of 3: 214 µs per loop
100 loops, best of 3: 128 µs per loop
100 loops, best of 3: 56.1 µs per loop
</code></p>

<h3>8.使用join合并迭代器中的字符串</h3>

<p>`&ldquo;
In [1]: %%timeit
   &hellip;: s = &rdquo;
   &hellip;: for i in a:
   &hellip;:         s += i
   &hellip;:
10000 loops, best of 3: 59.8 µs per loop</p>

<p>In [2]: %%timeit
s = &lsquo;&rsquo;.join(a)
   &hellip;:
100000 loops, best of 3: 11.8 µs per loop
```
join对于累加的方式，有大约5倍的提升。</p>

<h3>9.选择合适的格式化字符方式</h3>

<p><code>
s1, s2 = 'ax', 'bx'
%timeit -n 100000 'abc%s%s' % (s1, s2)
%timeit -n 100000 'abc{0}{1}'.format(s1, s2)
%timeit -n 100000 'abc' + s1 + s2
100000 loops, best of 3: 183 ns per loop
100000 loops, best of 3: 169 ns per loop
100000 loops, best of 3: 103 ns per loop
</code>
三种情况中，%的方式是最慢的，但是三者的差距并不大（都非常快）。(个人觉得%的可读性最好)</p>

<h3>10.不借助中间变量交换两个变量的值</h3>

<p>```
In [3]: %%timeit -n 10000</p>

<pre><code>a,b=1,2
</code></pre>

<p>   &hellip;.: c=a;a=b;b=c;
   &hellip;.:
10000 loops, best of 3: 172 ns per loop</p>

<p>In [4]: %%timeit -n 10000
a,b=1,2
a,b=b,a
   &hellip;.:
10000 loops, best of 3: 86 ns per loop
```
使用a,b=b,a而不是c=a;a=b;b=c;来交换a,b的值，可以快1倍以上。</p>

<h3>11.使用if is</h3>

<p><code>
a = range(10000)
%timeit -n 100 [i for i in a if i == True]
%timeit -n 100 [i for i in a if i is True]
100 loops, best of 3: 531 µs per loop
100 loops, best of 3: 362 µs per loop
</code>
使用 if is True 比 if == True 将近快一倍。</p>

<h3>12.使用级联比较x &lt; y &lt; z</h3>

<p><code>
x, y, z = 1,2,3
%timeit -n 1000000 if x &lt; y &lt; z:pass
%timeit -n 1000000 if x &lt; y and y &lt; z:pass
1000000 loops, best of 3: 101 ns per loop
1000000 loops, best of 3: 121 ns per loop
</code>
x &lt; y &lt; z效率略高，而且可读性更好。</p>

<h3>13.while 1 比 while True 更快</h3>

<p>```
def while_1():</p>

<pre><code>n = 100000
while 1:
    n -= 1
    if n &lt;= 0: break
</code></pre>

<p>def while_true():</p>

<pre><code>n = 100000
while True:
    n -= 1
    if n &lt;= 0: break    
</code></pre>

<p>m, n = 1000000, 1000000
%timeit -n 100 while_1()
%timeit -n 100 while_true()
100 loops, best of 3: 3.69 ms per loop
100 loops, best of 3: 5.61 ms per loop
```
while 1 比 while true快很多，原因是在python2.x中，True是一个全局变量，而非关键字。</p>

<h3>14.使用**而不是pow</h3>

<p><code>
%timeit -n 10000 c = pow(2,20)
%timeit -n 10000 c = 2**20
10000 loops, best of 3: 284 ns per loop
10000 loops, best of 3: 16.9 ns per loop
</code>
**就是快10倍以上！</p>

<h3>15.使用 cProfile, cStringIO 和 cPickle等用c实现相同功能（分别对应profile, StringIO, pickle）的包</h3>

<p><code>
import cPickle
import pickle
a = range(10000)
%timeit -n 100 x = cPickle.dumps(a)
%timeit -n 100 x = pickle.dumps(a)
100 loops, best of 3: 1.58 ms per loop
100 loops, best of 3: 17 ms per loop
</code>
由c实现的包，速度快10倍以上！</p>

<h3>16.使用最佳的反序列化方式</h3>

<p>下面比较了eval, cPickle, json方式三种对相应字符串反序列化的效率：
<code>
import json
import cPickle
a = range(10000)
s1 = str(a)
s2 = cPickle.dumps(a)
s3 = json.dumps(a)
%timeit -n 100 x = eval(s1)
%timeit -n 100 x = cPickle.loads(s2)
%timeit -n 100 x = json.loads(s3)
100 loops, best of 3: 16.8 ms per loop
100 loops, best of 3: 2.02 ms per loop
100 loops, best of 3: 798 µs per loop
</code>
可见json比cPickle快近3倍，比eval快20多倍。(这个跟前文测试有冲突，数据量的问题)</p>

<h3>17.使用C扩展(Extension)</h3>

<p>目前主要有CPython(python最常见的实现的方式)原生API, ctypes,Cython，cffi三种方式，它们的作用是使得Python程序可以调用由C编译成的动态链接库，其特点分别是：</p>

<p>CPython原生API: 通过引入Python.h头文件，对应的C程序中可以直接使用Python的数据结构。实现过程相对繁琐，但是有比较大的适用范围。</p>

<p>ctypes: 通常用于封装(wrap)C程序，让纯Python程序调用动态链接库（Windows中的dll或Unix中的so文件）中的函数。如果想要在python中使用已经有C类库，使用ctypes是很好的选择，有一些基准测试下，python2+ctypes是性能最好的方式。</p>

<p>Cython: Cython是CPython的超集，用于简化编写C扩展的过程。Cython的优点是语法简洁，可以很好地兼容numpy等包含大量C扩展的库。Cython的使得场景一般是针对项目中某个算法或过程的优化。在某些测试中，可以有几百倍的性能提升。</p>

<p>cffi: cffi的就是ctypes在pypy（详见下文）中的实现，同进也兼容CPython。cffi提供了在python使用C类库的方式，可以直接在python代码中编写C代码，同时支持链接到已有的C类库。</p>

<p>使用这些优化方式一般是针对已有项目性能瓶颈模块的优化，可以在少量改动原有项目的情况下大幅度地提高整个程序的运行效率。</p>

<h3>18.并行编程</h3>

<p>因为GIL的存在，Python很难充分利用多核CPU的优势。但是，可以通过内置的模块multiprocessing实现下面几种并行模式：</p>

<p>多进程：对于CPU密集型的程序，可以使用multiprocessing的Process,Pool等封装好的类，通过多进程的方式实现并行计算。但是因为进程中的通信成本比较大，对于进程之间需要大量数据交互的程序效率未必有大的提高。</p>

<p>多线程：对于IO密集型的程序，multiprocessing.dummy模块使用multiprocessing的接口封装threading，使得多线程编程也变得非常轻松(比如可以使用Pool的map接口，简洁高效)。</p>

<p>分布式：multiprocessing中的Managers类提供了可以在不同进程之共享数据的方式，可以在此基础上开发出分布式的程序。</p>

<p>不同的业务场景可以选择其中的一种或几种的组合实现程序性能的优化。</p>

<h3>19.终级大杀器：PyPy</h3>

<p>PyPy是用RPython(CPython的子集)实现的Python，根据官网的基准测试数据，它比CPython实现的Python要快6倍以上。快的原因是使用了Just-in-Time(JIT)编译器，即动态编译器，与静态编译器(如gcc,javac等)不同，它是利用程序运行的过程的数据进行优化。由于历史原因，目前pypy中还保留着GIL，不过正在进行的STM项目试图将PyPy变成没有GIL的Python。</p>

<p>如果python程序中含有C扩展(非cffi的方式)，JIT的优化效果会大打折扣，甚至比CPython慢（比Numpy）。所以在PyPy中最好用纯Python或使用cffi扩展。</p>

<p>随着STM，Numpy等项目的完善，相信PyPy将会替代CPython。</p>

<h3>20.使用性能分析工具</h3>

<p>除了上面在ipython使用到的timeit模块，还有cProfile。cProfile的使用方式也非常简单： python -m cProfile filename.py，filename.py 是要运行程序的文件名，可以在标准输出中看到每一个函数被调用的次数和运行的时间，从而找到程序的性能瓶颈，然后可以有针对性地优化。</p>

<p>参考</p>

<p>[1] <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/">http://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/</a></p>

<p>[2] <a href="http://maxburstein.com/blog/speeding-up-your-python-code/">http://maxburstein.com/blog/speeding-up-your-python-code/</a></p>

<p>备注：<br>
1.降低方法调用次数，如果你有一个列表需要操作，传递整个列表，而不是遍历整个列表并且传递每个元素给函数并返回。<br>
2.使用 xrange 代替 range。（在 Python2.x 中这样做，因为 Python 3.x 中是默认的）xrange 是 range 的 C 实现，着眼于有效的内存使用。<br>
3.对于大数据，使用 numpy，它比标准的数据结构好很多。<br>
4.&ldquo;&rdquo;.join(string) 比 + or += 好<br>
5.while 1 比 while True 快<br>
6.list comphrension > for loop > while<br>
7.列表推导比循环遍历列表快，但 while loop 是最慢的，需要使用一个外部计数器。<br>
8.使用 cProfile，cStringIO 和 cPickle<br>
一直使用 C 版本的模块<br>
9.使用局部变量<br>
局部变量比全局变量，内建类型以及属性快。<br>
10.列表和迭代器版本存在 &ndash; 迭代器是内存效率和可伸缩性的。使用 itertools<br>
11.创建生成器以及尽可能使用 yeild，它们比正常的列表方式更快。<br>
12.使用 Map ，Reduce 和 Filter 代替 for 循环<br>
Map的用法：map(函数, 序列)，对于序列中规定每个元素，调用函数，把所有返回值放到一个list中。
```</p>

<blockquote><blockquote><blockquote><p>map(lambda x: x*x, range(1, 11)) # 队列中每个元素求平方然后返回一个新的队列
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
<code>
Reduce的用法：reduce(函数, 序列)，将序列中的元素依据函数的操作合并起来，最终返回一个结果。
</code>
reduce(lambda x,y : x+y, range(1, 11)) # 返回队列中所有的元素的总和
55
<code>
Filter的用法：filter(函数, 序列)，依据函数的返回值过滤序列中的元素，函数返回真（非0）则保留元素，返回假（0）则不保留。
</code>
filter(lambda x: x%3==0, range(1, 11)) # 返回队列中能被3整除的元素组成的新队列
[3, 6, 9]
```
13.校验 a in b， 字典 或 set 比 列表 或 元组 更好<br>
14.当数据量大的时候，尽可能使用不可变数据类型，他们更快 元组 > 列表<br>
15.在一个列表中插入数据的复杂度为 O(n)<br>
16.如果你需要操作列表的两端，使用 deque<br>
17.del &ndash; 删除对象使用如下<br>
1） python 自己处理它，但确保使用了 gc 模块<br>
2） 编写 <strong>del</strong> 函数<br>
3） 最简单的方式，使用后调用 del<br>
18.time.clock()<br>
19.GIL(<a href="http://wiki.python.org/moin/GlobalInterpreterLock">http://wiki.python.org/moin/GlobalInterpreterLock</a>) &ndash; GIL is a daemon<br>
GIL 仅仅允许一个 Python 的原生线程来运行每个进程。阻止 CPU 级别的并行，尝试使用 ctypes 和 原生的 C 库来解决它，当你达到 Python 优化的最后，总是存在一个选项，可以使用原生的 C 重写慢的函数，通过 Python 的 C 绑定使用它，其他的库如 gevent 也是致力于解决这个问题，并且获得了成功。
TL,DR：当你写代码了，过一遍数据结构，迭代结构，内建和为 GIL 创建 C 扩展，如有必要。
更新：multiprocessing 是在 GIL 的范围之外，这意味着你可以使用 multiprocessing 这个标准库来运行多个进程。</p></blockquote></blockquote></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python中反射和自省]]></title>
    <link href="http://yindashan.github.io/blog/2014/10/26/pythonzhong-fan-she-he-zi-sheng/"/>
    <updated>2014-10-26T15:40:10+08:00</updated>
    <id>http://yindashan.github.io/blog/2014/10/26/pythonzhong-fan-she-he-zi-sheng</id>
    <content type="html"><![CDATA[<p>一提到反射，总让人望而却步，感觉是一个比较高深的概念，今天抽时间重点研究了一下Python中反射的用法，特此记录。
什么是反射？简单来说，就是动态调用一个函数或者一个类对象里的函数。
什么时候用到反射呢？有时候我们会需要执行对象的某个方法，或是需要对对象的某个属性赋值，而方法名或者属性名在编码代码时并不能确定，需要通过参数传递字符串的形式输入。
当然，反射的内容不仅仅包含这些，还诸如获取和设置对象属性，访问对象元数据，生成器，代码，栈帧等，大家有兴趣的话可以自行查阅一下。</p>

<p>反射是个很吓唬人的名词，听起来高深莫测，在一般的编程语言里反射相对其他概念来说稍显复杂，一般来说都是作为高级主题来讲；但在Python中反射非常简单，用起来几乎感觉不到与其他的代码有区别，使用反射获取到的函数和方法可以像平常一样加上括号直接调用，获取到类后可以直接构造实例；不过获取到的字段不能直接赋值，因为拿到的其实是另一个指向同一个地方的引用，赋值只能改变当前的这个引用而已。</p>

<p>下面这位兄弟的博客，讲的很清析，可以参考一下：
<a href="http://www.cnblogs.com/huxi/archive/2011/01/02/1924317.html">http://www.cnblogs.com/huxi/archive/2011/01/02/1924317.html</a></p>

<p>首先通过一个例子来看一下本文中可能用到的对象和相关概念。</p>

<p>```</p>

<h1>coding: UTF-8</h1>

<p>import sys #  模块，sys指向这个模块对象
import inspect
def foo(): pass # 函数，foo指向这个函数对象</p>

<p>class Cat(object): # 类，Cat指向这个类对象</p>

<pre><code>def __init__(self, name='kitty'):
    self.name = name
def sayHi(self): #  实例方法，sayHi指向这个方法对象，使用类或实例.sayHi访问
    print self.name, 'says Hi!' # 访问名为name的字段，使用实例.name访问
</code></pre>

<p>cat = Cat() # cat是Cat类的实例对象</p>

<p>print Cat.sayHi # 使用类名访问实例方法时，方法是未绑定的(unbound)
print cat.sayHi # 使用实例访问实例方法时，方法是绑定的(bound)
```
有时候我们会碰到这样的需求，需要执行对象的某个方法，或是需要对对象的某个字段赋值，而方法名或是字段名在编码代码时并不能确定，需要通过参数传递字符串的形式输入。举个具体的例子：当我们需要实现一个通用的DBM框架时，可能需要对数据对象的字段赋值，但我们无法预知用到这个框架的数据对象都有些什么字段，换言之，我们在写框架的时候需要通过某种机制访问未知的属性。</p>

<p>这个机制被称为反射（反过来让对象告诉我们他是什么），或是自省（让对象自己告诉我们他是什么，好吧我承认括号里是我瞎掰的- &ndash;#），用于实现在运行时获取未知对象的信息。反射是个很吓唬人的名词，听起来高深莫测，在一般的编程语言里反射相对其他概念来说稍显复杂，一般来说都是作为高级主题来讲；但在Python中反射非常简单，用起来几乎感觉不到与其他的代码有区别，使用反射获取到的函数和方法可以像平常一样加上括号直接调用，获取到类后可以直接构造实例；不过获取到的字段不能直接赋值，因为拿到的其实是另一个指向同一个地方的引用，赋值只能改变当前的这个引用而已。</p>

<h2>1. 访问对象的属性</h2>

<p>以下列出了几个内建方法，可以用来检查或是访问对象的属性。这些方法可以用于任意对象而不仅仅是例子中的Cat实例对象；Python中一切都是对象。</p>

<p>```
cat = Cat(&lsquo;kitty&rsquo;)</p>

<p>print cat.name # 访问实例属性
cat.sayHi() # 调用实例方法</p>

<p>print dir(cat) # 获取实例的属性名，以列表形式返回
if hasattr(cat, &lsquo;name&rsquo;): # 检查实例是否有这个属性</p>

<pre><code>setattr(cat, 'name', 'tiger') # same as: a.name = 'tiger'
</code></pre>

<p>print getattr(cat, &lsquo;name&rsquo;) # same as: print a.name</p>

<p>getattr(cat, &lsquo;sayHi&rsquo;)() # same as: cat.sayHi()
dir([obj]):
<code>
调用这个方法将返回包含obj大多数属性名的列表（会有一些特殊的属性不包含在内）。obj的默认值是当前的模块对象。
</code>
hasattr(obj, attr):
<code>
这个方法用于检查obj是否有一个名为attr的值的属性，返回一个布尔值。
</code>
getattr(obj, attr):
<code>
调用这个方法将返回obj中名为attr值的属性的值，例如如果attr为'bar'，则返回obj.bar。
</code>
setattr(obj, attr, val):
```
调用这个方法将给obj的名为attr的值的属性赋值为val。例如如果attr为'bar'，则相当于obj.bar = val。</p>

<h2>2. 访问对象的元数据</h2>

<p>当你对一个你构造的对象使用dir()时，可能会发现列表中的很多属性并不是你定义的。这些属性一般保存了对象的元数据，比如类的<strong>name</strong>属性保存了类名。大部分这些属性都可以修改，不过改动它们意义并不是很大；修改其中某些属性如function.func_code还可能导致很难发现的问题，所以改改name什么的就好了，其他的属性不要在不了解后果的情况下修改。</p>

<p>接下来列出特定对象的一些特殊属性。另外，Python的文档中有提到部分属性不一定会一直提供，下文中将以红色的星号*标记，使用前你可以先打开解释器确认一下。</p>

<h3>2.0. 准备工作：确定对象的类型</h3>

<p>在types模块中定义了全部的Python内置类型，结合内置方法isinstance()就可以确定对象的具体类型了。
<code>
isinstance(object, classinfo):
</code>
检查object是不是classinfo中列举出的类型，返回布尔值。classinfo可以是一个具体的类型，也可以是多个类型的元组或列表。
types模块中仅仅定义了类型，而inspect模块中封装了很多检查类型的方法，比直接使用types模块更为轻松，所以这里不给出关于types的更多介绍，如有需要可以直接查看types模块的文档说明。本文第3节中介绍了inspect模块。</p>

<h3>2.1. 模块(module)</h3>

<p><strong>doc</strong>: 文档字符串。如果模块没有文档，这个值是None。
<em><strong>name</strong>: 始终是定义时的模块名；即使你使用import .. as 为它取了别名，或是赋值给了另一个变量名。
</em><strong>dict</strong>: 包含了模块里可用的属性名-属性的字典；也就是可以使用模块名.属性名访问的对象。
<strong>file</strong>: 包含了该模块的文件路径。需要注意的是内建的模块没有这个属性，访问它会抛出异常！
<code>
import fnmatch as m
print m.__doc__.splitlines()[0] # Filename matching with shell patterns.
print m.__name__                # fnmatch
print m.__file__                # /usr/lib/python2.6/fnmatch.pyc
print m.__dict__.items()[0]     # ('fnmatchcase', &lt;function&gt;)&lt;/function&gt;
</code></p>

<h3>2.2. 类(class)</h3>

<p><strong>doc</strong>: 文档字符串。如果类没有文档，这个值是None。
<em><strong>name</strong>: 始终是定义时的类名。
</em><strong>dict</strong>: 包含了类里可用的属性名-属性的字典；也就是可以使用类名.属性名访问的对象。
<strong>module</strong>: 包含该类的定义的模块名；需要注意，是字符串形式的模块名而不是模块对象。
*<strong>bases</strong>: 直接父类对象的元组；但不包含继承树更上层的其他类，比如父类的父类。
<code>
print Cat.__doc__           # None
print Cat.__name__          # Cat
print Cat.__module__        # __main__
print Cat.__bases__         # (&lt;type&gt;,)
print Cat.__dict__          # {'__module__': '__main__', ...}&lt;/type&gt;
</code></p>

<h3>2.3. 实例(instance)</h3>

<p>实例是指类实例化以后的对象。</p>

<p><em><strong>dict</strong>: 包含了可用的属性名-属性字典。
</em><strong>class</strong>: 该实例的类对象。对于类Cat，cat.<strong>class</strong> == Cat 为 True。
<code>
print cat.__dict__
print cat.__class__
print cat.__class__ == Cat # True
</code></p>

<h3>2.4. 内建函数和方法(built-in functions and methods)</h3>

<p>根据定义，内建的(built-in)模块是指使用C写的模块，可以通过sys模块的builtin_module_names字段查看都有哪些模块是内建的。这些模块中的函数和方法可以使用的属性比较少，不过一般也不需要在代码中查看它们的信息。</p>

<p><strong>doc</strong>: 函数或方法的文档。
<strong>name</strong>: 函数或方法定义时的名字。
<strong>self</strong>: 仅方法可用，如果是绑定的(bound)，则指向调用该方法的类（如果是类方法）或实例（如果是实例方法），否则为None。
*<strong>module</strong>: 函数或方法所在的模块名。</p>

<h3>2.5. 函数(function)</h3>

<p>这里特指非内建的函数。注意，在类中使用def定义的是方法，方法与函数虽然有相似的行为，但它们是不同的概念。</p>

<p><strong>doc</strong>: 函数的文档；另外也可以用属性名func_doc。
<strong>name</strong>: 函数定义时的函数名；另外也可以用属性名func_name。
<em><strong>module</strong>: 包含该函数定义的模块名；同样注意，是模块名而不是模块对象。
</em><strong>dict</strong>: 函数的可用属性；另外也可以用属性名func_dict。
不要忘了函数也是对象，可以使用函数.属性名访问属性（赋值时如果属性不存在将新增一个），或使用内置函数has/get/setattr()访问。不过，在函数中保存属性的意义并不大。
func_defaults: 这个属性保存了函数的参数默认值元组；因为默认值总是靠后的参数才有，所以不使用字典的形式也是可以与参数对应上的。
func_code: 这个属性指向一个该函数对应的code对象，code对象中定义了其他的一些特殊属性，将在下文中另外介绍。
func_globals: 这个属性指向定义函数时的全局命名空间。
*func_closure: 这个属性仅当函数是一个闭包时有效，指向一个保存了所引用到的外部函数的变量cell的元组，如果该函数不是一个内部函数，则始终为None。这个属性也是只读的。
下面的代码演示了func_closure：</p>

<p>```</p>

<h1>coding: UTF-8</h1>

<p>def foo():</p>

<pre><code>n = 1
def bar():
    print n # 引用非全局的外部变量n，构造一个闭包
n = 2
return bar
</code></pre>

<p>closure = foo()
print closure.func_closure
```</p>

<h1>使用dir()得知cell对象有一个cell_contents属性可以获得值</h1>

<p><code>
print closure.func_closure[0].cell_contents # 2
</code>
由这个例子可以看到，遇到未知的对象使用dir()是一个很好的主意 ：）</p>

<h3>2.6. 方法(method)</h3>

<p>方法虽然不是函数，但可以理解为在函数外面加了一层外壳；拿到方法里实际的函数以后，就可以使用2.5节的属性了。</p>

<p><strong>doc</strong>: 与函数相同。
<strong>name</strong>: 与函数相同。
*<strong>module</strong>: 与函数相同。
im_func: 使用这个属性可以拿到方法里实际的函数对象的引用。另外如果是2.6以上的版本，还可以使用属性名<strong>func</strong>。
im_self: 如果是绑定的(bound)，则指向调用该方法的类（如果是类方法）或实例（如果是实例方法），否则为None。如果是2.6以上的版本，还可以使用属性名<strong>self</strong>。
im_class: 实际调用该方法的类，或实际调用该方法的实例的类。注意不是方法的定义所在的类，如果有继承关系的话。
<code>
im = cat.sayHi
print im.im_func
print im.im_self # cat
print im.im_class # Cat
</code>
这里讨论的是一般的实例方法，另外还有两种特殊的方法分别是类方法(classmethod)和静态方法(staticmethod)。类方法还是方法，不过因为需要使用类名调用，所以他始终是绑定的；而静态方法可以看成是在类的命名空间里的函数（需要使用类名调用的函数），它只能使用函数的属性，不能使用方法的属性。</p>

<h3>2.7. 生成器(generator)</h3>

<p>生成器是调用一个生成器函数(generator function)返回的对象，多用于集合对象的迭代。</p>

<p><strong>iter</strong>: 仅仅是一个可迭代的标记。
gi_code: 生成器对应的code对象。
gi_frame: 生成器对应的frame对象。
gi_running: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。
next|close|send|throw: 这是几个可调用的方法，并不包含元数据信息，如何使用可以查看生成器的相关文档。
```
def gen():</p>

<pre><code>for n in xrange(5):
    yield n
</code></pre>

<p>g = gen()
print g             # <generator object gen at 0x...>
print g.gi_code     # <code object gen at 0x...>
print g.gi_frame    # <frame object at 0x...>
print g.gi_running  # 0
print g.next()      # 0
print g.next()      # 1
for n in g:</p>

<pre><code>print n,        # 2 3 4
</code></pre>

<p>```
接下来讨论的是几个不常用到的内置对象类型。这些类型在正常的编码过程中应该很少接触，除非你正在自己实现一个解释器或开发环境之类。所以这里只列出一部分属性，如果需要一份完整的属性表或想进一步了解，可以查看文末列出的参考文档。</p>

<h3>2.8. 代码块(code)</h3>

<p>代码块可以由类源代码、函数源代码或是一个简单的语句代码编译得到。这里我们只考虑它指代一个函数时的情况；2.5节中我们曾提到可以使用函数的func_code属性获取到它。code的属性全部是只读的。</p>

<p>co_argcount: 普通参数的总数，不包括<em>参数和**参数。
co_names: 所有的参数名（包括</em>参数和<strong>参数）和局部变量名的元组。
co_varnames: 所有的局部变量名的元组。
co_filename: 源代码所在的文件名。
co_flags:  这是一个数值，每一个二进制位都包含了特定信息。较关注的是0b100(0x4)和0b1000(0x8)，如果co_flags &amp; 0b100 != 0，说明使用了*args参数；如果co_flags &amp; 0b1000 != 0，说明使用了</strong>kwargs参数。另外，如果co_flags &amp; 0b100000(0x20) != 0，则说明这是一个生成器函数(generator function)。
<code>
co = cat.sayHi.func_code
print co.co_argcount        # 1
print co.co_names           # ('name',)
print co.co_varnames        # ('self',)
print co.co_flags &amp; 0b100   # 0
</code></p>

<h3>2.9. 栈帧(frame)</h3>

<p>栈帧表示程序运行时函数调用栈中的某一帧。函数没有属性可以获取它，因为它在函数调用时才会产生，而生成器则是由函数调用返回的，所以有属性指向栈帧。想要获得某个函数相关的栈帧，则必须在调用这个函数且这个函数尚未返回时获取。你可以使用sys模块的_getframe()函数、或inspect模块的currentframe()函数获取当前栈帧。这里列出来的属性全部是只读的。</p>

<p>f_back: 调用栈的前一帧。
f_code: 栈帧对应的code对象。
f_locals: 用在当前栈帧时与内建函数locals()相同，但你可以先获取其他帧然后使用这个属性获取那个帧的locals()。
f_globals: 用在当前栈帧时与内建函数globals()相同，但你可以先获取其他帧……。
```
def add(x, y=1):</p>

<pre><code>f = inspect.currentframe()
print f.f_locals    # same as locals()
print f.f_back      # &lt;frame object at 0x...&gt;
return x+y
</code></pre>

<p>add(2)
```</p>

<h3>2.10. 追踪(traceback)</h3>

<p>追踪是在出现异常时用于回溯的对象，与栈帧相反。由于异常时才会构建，而异常未捕获时会一直向外层栈帧抛出，所以需要使用try才能见到这个对象。你可以使用sys模块的exc_info()函数获得它，这个函数返回一个元组，元素分别是异常类型、异常对象、追踪。traceback的属性全部是只读的。</p>

<p>tb_next: 追踪的下一个追踪对象。
tb_frame: 当前追踪对应的栈帧。
tb_lineno: 当前追踪的行号。
```
def div(x, y):</p>

<pre><code>try:
    return x/y
except:
    tb = sys.exc_info()[2]  # return (exc_type, exc_value, traceback)
    print tb
    print tb.tb_lineno      # "return x/y" 的行号
</code></pre>

<p>div(1, 0)
```</p>

<h2>3. 使用inspect模块</h2>

<p>inspect模块提供了一系列函数用于帮助使用自省。下面仅列出较常用的一些函数，想获得全部的函数资料可以查看inspect模块的文档。</p>

<h3>3.1. 检查对象类型</h3>

<p>is{module|class|function|method|builtin}(obj):
检查对象是否为模块、类、函数、方法、内建函数或方法。
isroutine(obj):
用于检查对象是否为函数、方法、内建函数或方法等等可调用类型。用这个方法会比多个is<em>()更方便，不过它的实现仍然是用了多个is</em>()。
```
im = cat.sayHi
if inspect.isroutine(im):</p>

<pre><code>im()
</code></pre>

<p>```
对于实现了<strong>call</strong>的类实例，这个方法会返回False。如果目的是只要可以直接调用就需要是True的话，不妨使用isinstance(obj, collections.Callable)这种形式。我也不知道为什么Callable会在collections模块中，抱歉！我猜大概是因为collections模块中包含了很多其他的ABC(Abstract Base Class)的缘故吧：）</p>

<h3>3.2. 获取对象信息</h3>

<p><code>
getmembers(object[, predicate]):
</code>
这个方法是dir()的扩展版，它会将dir()找到的名字对应的属性一并返回，形如[(name, value), &hellip;]。另外，predicate是一个方法的引用，如果指定，则应当接受value作为参数并返回一个布尔值，如果为False，相应的属性将不会返回。使用is<em>作为第二个参数可以过滤出指定类型的属性。
<code>
getmodule(object):
</code>
还在为第2节中的<strong>module</strong>属性只返回字符串而遗憾吗？这个方法一定可以满足你，它返回object的定义所在的模块对象。
<code>
get{file|sourcefile}(object):
</code>
获取object的定义所在的模块的文件名|源代码文件名（如果没有则返回None）。用于内建的对象（内建模块、类、函数、方法）上时会抛出TypeError异常。
<code>
get{source|sourcelines}(object):
</code>
获取object的定义的源代码，以字符串|字符串列表返回。代码无法访问时会抛出IOError异常。只能用于module/class/function/method/code/frame/traceack对象。
<code>
getargspec(func):
</code>
仅用于方法，获取方法声明的参数，返回元组，分别是(普通参数名的列表, </em>参数名, <em>*参数名, 默认值元组)。如果没有值，将是空列表和3个None。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。<br/>
```
def add(x, y=1, </em>z):</p>

<pre><code>return x + y + sum(z)
</code></pre>

<p>print inspect.getargspec(add)</p>

<h1>ArgSpec(args=[&lsquo;x&rsquo;, &lsquo;y&rsquo;], varargs=&lsquo;z&rsquo;, keywords=None, defaults=(1,))</h1>

<p>getargvalues(frame):
<code>
仅用于栈帧，获取栈帧中保存的该次函数调用的参数值，返回元组，分别是(普通参数名的列表, *参数名, **参数名, 帧的locals())。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。
</code>
def add(x, y=1, *z):</p>

<pre><code>print inspect.getargvalues(inspect.currentframe())
return x + y + sum(z)
</code></pre>

<p>add(2)</p>

<h1>ArgInfo(args=[&lsquo;x&rsquo;, &lsquo;y&rsquo;], varargs=&lsquo;z&rsquo;, keywords=None, locals={&lsquo;y&rsquo;: 1, &lsquo;x&rsquo;: 2, &lsquo;z&rsquo;: ()})</h1>

<p>getcallargs(func[, *args][, **kwds]):
<code>
返回使用args和kwds调用该方法时各参数对应的值的字典。这个方法仅在2.7版本中才有。
</code>
getmro(cls):
<code>
返回一个类型元组，查找类属性时按照这个元组中的顺序。如果是新式类，与cls.__mro__结果一样。但旧式类没有__mro__这个属性，直接使用这个属性会报异常，所以这个方法还是有它的价值的。
</code>
print inspect.getmro(Cat)</p>

<h1>(<class '__main__.Cat'>, <type 'object'>)</h1>

<p>print Cat.<strong>mro</strong></p>

<h1>(<class '__main__.Cat'>, <type 'object'>)</h1>

<p>class Dog: pass
print inspect.getmro(Dog)</p>

<h1>(<class __main__.Dog at 0x...>,)</h1>

<p>print Dog.<strong>mro</strong> # AttributeError
currentframe():
```
返回当前的栈帧对象。
其他的操作frame和traceback的函数请查阅inspect模块的文档，用的比较少，这里就不多介绍了。</p>

<h2>4. 本地测试代码</h2>

<h3>4.1. 简单用法</h3>

<p>```</p>

<h1>!/usr/bin/env python</h1>

<h1>coding: utf-8</h1>

<p>&lsquo;&rsquo;&lsquo;
python中的反射
说起反射，大家应该都不陌生吧，特别是熟悉Java的程序员，一定经常和 Class.forName 打交道。
Java的众多框架中，如 Spring ， eclipse plugin 机制等很多都依赖于Java的反射技术。
感觉反射在Java中属于比较高级的技术，通常作为高级主题来讲述。
但是在Python中反射比java中简单得多。 使用反射获取到的函数和方法可以像平常一样加上括号直接调用，获取到类后可以直接构造实例。</p>

<blockquote><blockquote><blockquote><p>import json
methodList = [attr for attr in dir(json)  if callable(getattr(json,attr))]
methodList
[&lsquo;JSONDecoder&rsquo;, &lsquo;JSONEncoder&rsquo;, &lsquo;dump&rsquo;, &lsquo;dumps&rsquo;, &lsquo;load&rsquo;, &lsquo;loads&rsquo;]</p>

<p>&lsquo;&rsquo;&lsquo;
import sys #  模块，sys指向这个模块对象
import inspect
def foo(): pass # 函数，foo指向这个函数对象</p></blockquote></blockquote></blockquote>

<p>class Cat(object): # 类，Cat指向这个类对象</p>

<pre><code>def __init__(self, name='kitty'):
    self.name = name

def echo_methods(self):
    """ 输出类中所有的方法，以及doc 文档 """
    print "\n Method List: "
    for item_method in dir(self):
        attr = getattr(self, item_method)
        if callable(attr):
            print item_method,"():",attr.__doc__

def echo_attributes(self):
    print "\n Attributes"
    for item_attr in dir(self):
        attr = getattr(self, item_attr)
        if not callable(attr):
            print item_attr,":",attr

def sayHi(self): #  实例方法，sayHi指向这个方法对象，使用类或实例.sayHi访问
    print self.name, 'says Hi!' # 访问名为name的字段，使用实例.name访问

def print_name(self, name):
    self.name = name
    print self.name, 'print_name!'
</code></pre>

<p>def main():</p>

<pre><code>cat = Cat() # cat是Cat类的实例对象
print Cat.sayHi # 使用类名访问实例方法时，方法是未绑定的(unbound)
print cat.sayHi # 使用实例访问实例方法时，方法是绑定的(bound)

cat.echo_attributes()
cat.echo_methods()

cat = Cat('kitty')
print cat.name # 访问实例属性
cat.sayHi() # 调用实例方法

print dir(cat) # 获取实例的属性名，以列表形式返回
if hasattr(cat, 'name'): # 检查实例是否有这个属性
    setattr(cat, 'name', 'tiger') # same as: a.name = 'tiger'
print getattr(cat, 'name') # same as: print a.name

getattr(cat, 'sayHi')() # same as: cat.sayHi()
</code></pre>

<h1>for item in dir(cat):</h1>

<h1>if not item.startswith(&ldquo;__&rdquo;) and callable(getattr(cat, item)): # callable检查属性是否是可以调用的函数</h1>

<h1>func = getattr(cat, item)</h1>

<h1>func() # 调用函数</h1>

<pre><code>func = getattr(cat, "print_name")
if callable(func):
    func('hello')
</code></pre>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:</p>

<pre><code>main()
</code></pre>

<p>```</p>

<h3>4.2. 稍微复杂点的用法</h3>

<p>```</p>

<h1>&ndash;<em>&ndash; coding: UTF-8 &ndash;</em>&ndash;</h1>

<p>&lsquo;&rsquo;&lsquo;
python中反射用法
&rsquo;&lsquo;&rsquo;</p>

<p>import inspect
import re</p>

<h1>===============================================================================</h1>

<h1>测试</h1>

<h1>===============================================================================</h1>

<p>def _unittest(func, *cases):</p>

<pre><code>for case in cases:
    _functest(func, *case)
</code></pre>

<p>def _functest(func, isCkPass, *args, **kws):</p>

<pre><code>try:
    print 'isCkPass = ', isCkPass
    func(*args, **kws)
except Exception as e:
    print e
</code></pre>

<p>def _test1_simple():</p>

<pre><code>def foo1(i): print 'i=', i
_unittest(foo1, 
          (True, 1), 
          (False, 's'), 
          (False, None))

def foo2(s, x): pass
_unittest(foo2, 
          (True, 1, 2), 
          (False, 's', 's'))

def foo7(s, **kws): pass
_functest(foo7, True, s='a', a=1, b=2)
</code></pre>

<p>def _main():</p>

<pre><code>d = globals()
from types import FunctionType
print
for f in d:
    if f.startswith('_test'):
        f = d[f]
        if isinstance(f, FunctionType):
            f()
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>_main()
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python中json_pickle_cPickle在序列化时的性能对比]]></title>
    <link href="http://yindashan.github.io/blog/2014/10/25/pythonzhong-json-pickle-cpicklezai-xu-lie-hua-shi-de-dui-bi/"/>
    <updated>2014-10-25T10:51:57+08:00</updated>
    <id>http://yindashan.github.io/blog/2014/10/25/pythonzhong-json-pickle-cpicklezai-xu-lie-hua-shi-de-dui-bi</id>
    <content type="html"><![CDATA[<p>在上篇介绍python中装饰器的文章中(<a href="http://yindashan.github.io/blog/2014/10/24/pythonzhong-zhuang-shi-qi-xiang-jie/">http://yindashan.github.io/blog/2014/10/24/pythonzhong-zhuang-shi-qi-xiang-jie/</a>)提到一个装饰器实例，原来的打算是利用redis缓存减少请求的响应时间，第一次从数据库中获取数据，把数据回种到缓存，然后返回数据，第二次请求的时候直接从redis缓存中读取就可以了，经过实践发现性能并没有提升，反而下降了，这到底是什么情况呢？后来经过代码分析发现时间都花费在下面这行代码上了，足足会有4s.
<code>
json.loads(ret_data)
</code>
这个函数平常用的时候性能可以啊，完全能够满足自己的需求，这次到底是怎么回事？又经过一番分析，发现是由于ret_data数据量太大导致的，数据大概在15M左右，所以要把15M的字符数据转换成json对象这个太耗时了。从数据库中取数据才需要2s左右，现在从redis中取并解析完成需要将近5s,这显然不能满足需求。</p>

<p>既然在数据量比较大的情况下json.loads()函数性能不能满足需求，那就得寻找其他的解决方案了，最终发现python中的内建序列化库pickle和cPickle是一个不错的选择，想到就测，发现在同等数据量的情况下json.loads()需要消耗4s左右，pickle只需要消耗1.5s左右，而cPickle更快，只需要消耗300ms左右,取其中一组测试结果：
<code>
hget cost time:  0:00:00.052490
json.loads cost time:  0:00:04.859132
pickle.loads cost time:  0:00:01.458769
cPickle.loads cost time:  0:00:00.361623
</code></p>

<p>测试代码如下：
```
import json
import time
import datetime
import traceback
import pickle
import cPickle</p>

<p>import redis</p>

<p>def test_redis():</p>

<pre><code>"""
测试redis
"""
redis_db = redis.StrictRedis(host='127.0.0.1', port=6379, db=0, password='N6MXWf')

d1 = datetime.datetime.now()
ret_data = redis_db.hget('forecast_redis', '20141023')
d2 = datetime.datetime.now()
print 'hget cost time: ', d2 - d1
ret_data = json.loads(ret_data)
d3 = datetime.datetime.now()
print 'json.loads cost time: ', d3 - d2
ret_data = redis_db.hget('forecast_redis', '20141024')
d4 = datetime.datetime.now()
ret_data = pickle.loads(ret_data)
d5 = datetime.datetime.now()
print 'pickle.loads cost time: ', d5 - d4
ret_data = redis_db.hget('forecast_redis', '20141025')
d6 = datetime.datetime.now()
ret_data = cPickle.loads(ret_data)
d7 = datetime.datetime.now()
print 'cPickle.loads cost time: ', d7 - d6
print 'success'
</code></pre>

<p>def main():</p>

<pre><code>test_redis()
</code></pre>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:</p>

<pre><code>main()
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python中装饰器详解]]></title>
    <link href="http://yindashan.github.io/blog/2014/10/24/pythonzhong-zhuang-shi-qi-xiang-jie/"/>
    <updated>2014-10-24T21:59:08+08:00</updated>
    <id>http://yindashan.github.io/blog/2014/10/24/pythonzhong-zhuang-shi-qi-xiang-jie</id>
    <content type="html"><![CDATA[<p>一直对装饰器的概念很模糊，今天终于花时间重点研究了一下。Python中的装饰器就类似于Java中的面向切面编程，就是在函数执行前和执行后包装自定义的一些东西。关于装饰器的原理和简易实现可以参考这位兄弟的博客，写的很简单易懂。</p>

<p><a href="http://www.cnblogs.com/huxi/archive/2011/03/01/1967600.html">http://www.cnblogs.com/huxi/archive/2011/03/01/1967600.html</a></p>

<h2>1. 装饰器入门</h2>

<h3>1.1. 需求是怎么来的？</h3>

<p>装饰器的定义很是抽象，我们来看一个小例子。</p>

<p>```
def foo():</p>

<pre><code>print 'in foo()'
</code></pre>

<p>foo()
```
这是一个很无聊的函数没错。但是突然有一个更无聊的人，我们称呼他为B君，说我想看看执行这个函数用了多长时间，好吧，那么我们可以这样做：</p>

<p>```
import time
def foo():</p>

<pre><code>start = time.clock()
print 'in foo()'
end = time.clock()
print 'used:', end - start
</code></pre>

<p>foo()
```
很好，功能看起来无懈可击。可是蛋疼的B君此刻突然不想看这个函数了，他对另一个叫foo2的函数产生了更浓厚的兴趣。</p>

<p>怎么办呢？如果把以上新增加的代码复制到foo2里，这就犯了大忌了~复制什么的难道不是最讨厌了么！而且，如果B君继续看了其他的函数呢？</p>

<h3>1.2. 以不变应万变，是变也</h3>

<p>还记得吗，函数在Python中是一等公民，那么我们可以考虑重新定义一个函数timeit，将foo的引用传递给他，然后在timeit中调用foo并进行计时，这样，我们就达到了不改动foo定义的目的，而且，不论B君看了多少个函数，我们都不用去修改函数定义了！</p>

<p>```
import time</p>

<p>def foo():</p>

<pre><code>print 'in foo()'
</code></pre>

<p>def timeit(func):</p>

<pre><code>start = time.clock()
func()
end =time.clock()
print 'used:', end - start
</code></pre>

<p>timeit(foo)
```
看起来逻辑上并没有问题，一切都很美好并且运作正常！……等等，我们似乎修改了调用部分的代码。原本我们是这样调用的：foo()，修改以后变成了：timeit(foo)。这样的话，如果foo在N处都被调用了，你就不得不去修改这N处的代码。或者更极端的，考虑其中某处调用的代码无法修改这个情况，比如：这个函数是你交给别人使用的。</p>

<h3>1.3. 最大限度地少改动！</h3>

<p>既然如此，我们就来想想办法不修改调用的代码；如果不修改调用代码，也就意味着调用foo()需要产生调用timeit(foo)的效果。我们可以想到将timeit赋值给foo，但是timeit似乎带有一个参数……想办法把参数统一吧！如果timeit(foo)不是直接产生调用效果，而是返回一个与foo参数列表一致的函数的话……就很好办了，将timeit(foo)的返回值赋值给foo，然后，调用foo()的代码完全不用修改！</p>

<p>```</p>

<h1>&ndash;<em>&ndash; coding: UTF-8 &ndash;</em>&ndash;</h1>

<p>import time</p>

<p>def foo():</p>

<pre><code>print 'in foo()'
</code></pre>

<h1>定义一个计时器，传入一个，并返回另一个附加了计时功能的方法</h1>

<p>def timeit(func):</p>

<pre><code># 定义一个内嵌的包装函数，给传入的函数加上计时功能的包装
def wrapper():
    start = time.clock()
    func()
    end =time.clock()
    print 'used:', end - start

# 将包装后的函数返回, 记住一定要返回 ，不然外面调用foo的地方将会无函数可用。实际上此时foo=timeit(foo)
return wrapper
</code></pre>

<p>foo = timeit(foo)
foo()
```
这样，一个简易的计时器就做好了！我们只需要在定义foo以后调用foo之前，加上foo = timeit(foo)，就可以达到计时的目的，这也就是装饰器的概念，看起来像是foo被timeit装饰了。在在这个例子中，函数进入和退出时需要计时，这被称为一个横切面(Aspect)，这种编程方式被称为面向切面的编程(Aspect-Oriented Programming)。与传统编程习惯的从上往下执行方式相比较而言，像是在函数执行的流程中横向地插入了一段逻辑。在特定的业务领域里，能减少大量重复代码。面向切面编程还有相当多的术语，这里就不多做介绍，感兴趣的话可以去找找相关的资料。</p>

<p>这个例子仅用于演示，并没有考虑foo带有参数和有返回值的情况，完善它的重任就交给你了 ：）</p>

<h2>2. Python的额外支持</h2>

<h3>2.1. 语法糖</h3>

<p>上面这段代码看起来似乎已经不能再精简了，Python于是提供了一个语法糖来降低字符输入量。</p>

<p>```
import time</p>

<p>def timeit(func):</p>

<pre><code>def wrapper():
    start = time.clock()
    func()
    end =time.clock()
    print 'used:', end - start
return wrapper
</code></pre>

<p>@timeit
def foo():</p>

<pre><code>print 'in foo()'
</code></pre>

<p>foo()
```
重点关注第11行的@timeit，在定义上加上这一行与另外写foo = timeit(foo)完全等价，千万不要以为@有另外的魔力。除了字符输入少了一些，还有一个额外的好处：这样看上去更有装饰器的感觉。</p>

<h3>2.2. 内置的装饰器</h3>

<p>内置的装饰器有三个，分别是staticmethod、classmethod和property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。由于模块里可以定义函数，所以静态方法和类方法的用处并不是太多，除非你想要完全的面向对象编程。而属性也不是不可或缺的，Java没有属性也一样活得很滋润。从我个人的Python经验来看，我没有使用过property，使用staticmethod和classmethod的频率也非常低。</p>

<p>```
class Rabbit(object):</p>

<pre><code>def __init__(self, name):
    self._name = name

@staticmethod
def newRabbit(name):
    return Rabbit(name)

@classmethod
def newRabbit2(cls):
    return Rabbit('')

@property
def name(self):
    return self._name
</code></pre>

<p>```
这里定义的属性是一个只读属性，如果需要可写，则需要再定义一个setter：</p>

<p>```
@name.setter
def name(self, name):</p>

<pre><code>self._name = name
</code></pre>

<p>```</p>

<h3>2.3. functools模块</h3>

<p>functools模块提供了两个装饰器。这个模块是Python 2.5后新增的，一般来说大家用的应该都高于这个版本。但我平时的工作环境是2.4 T-T</p>

<h4>2.3.1. wraps(wrapped[, assigned][, updated]):</h4>

<p>这是一个很有用的装饰器。看过前一篇反射的朋友应该知道，函数是有几个特殊属性比如函数名，在被装饰后，上例中的函数名foo会变成包装函数的名字wrapper，如果你希望使用反射，可能会导致意外的结果。这个装饰器可以解决这个问题，它能将装饰过的函数的特殊属性保留。</p>

<p>```
import time
import functools</p>

<p>def timeit(func):</p>

<pre><code>@functools.wraps(func)
def wrapper():
    start = time.clock()
    func()
    end =time.clock()
    print 'used:', end - start
return wrapper
</code></pre>

<p>@timeit
def foo():</p>

<pre><code>print 'in foo()'
</code></pre>

<p>foo()
print foo.<strong>name</strong>
```
首先注意第5行，如果注释这一行，foo.<strong>name</strong>将是'wrapper'。另外相信你也注意到了，这个装饰器竟然带有一个参数。实际上，他还有另外两个可选的参数，assigned中的属性名将使用赋值的方式替换，而updated中的属性名将使用update的方式合并，你可以通过查看functools的源代码获得它们的默认值。对于这个装饰器，相当于wrapper = functools.wraps(func)(wrapper)。</p>

<h2>3. 下面是我本地测试的一些示例</h2>

<h3>3.1. 普通装饰器</h3>

<p>```
def common(func):</p>

<pre><code>'''普通装饰器'''
def _deco(*args, **kwargs):
    print 'args:', args
    return func(*args, **kwargs)
return _deco
</code></pre>

<p>@common
def test_common(p):</p>

<pre><code>print p
</code></pre>

<p>def main():</p>

<pre><code>test_common(1)
</code></pre>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:</p>

<pre><code>main()
</code></pre>

<p>```</p>

<h3>3.2. 给函数的类装饰器(避免在装饰器对象上保留状态)</h3>

<p>```
class Common(object):</p>

<pre><code>'''给函数的类装饰器(避免在装饰器对象上保留状态)'''
def __init__(self, func):
    self.func = func
def __call__(self, *args, **kwargs):
    print 'args:', args
    return self.func(*args, **kwargs)
</code></pre>

<p>@Common
def test_common_class(p):</p>

<pre><code>print p
</code></pre>

<p>def main():</p>

<pre><code>test_common_class(2)
</code></pre>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:</p>

<pre><code>main()
</code></pre>

<p>```</p>

<h3>3.3. 带参数的装饰器</h3>

<p>```
def common_arg(*args, **kw):</p>

<pre><code>'''带参数的装饰器'''
a = args
b = kw
def _common_arg(func):
    def _deco(*args, **kwargs):
        print 'args:', args, a, b
        return func(*args, **kwargs)
    return _deco
return _common_arg
</code></pre>

<p>@common_arg(&lsquo;c&rsquo;, &rsquo;d', e=1)
def test_common_arg(p):</p>

<pre><code>print p
</code></pre>

<p>def main():</p>

<pre><code>test_common_arg(3)
</code></pre>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:</p>

<pre><code>main()
</code></pre>

<p>```</p>

<h3>3.4. 一个比较实用的示例</h3>

<p>模拟从数据库中获取数据，第一次从数据库中获取，获取成功后保存到redis里面，以后每次都从redis里面获取
```
import json
import redis</p>

<p>def redis_cache(*args, **kwargs):</p>

<pre><code>redis_link_dict = kwargs
print redis_link_dict
redis_db = redis.StrictRedis(redis_link_dict['host'], redis_link_dict['port'], redis_link_dict['db'], redis_link_dict['password'])
def _decorator(func):
    def _wrapped(*args, **kwargs):
        key, hash_key = args
        print key, hash_key
        # 判断当前key是否存在
        is_key = redis_db.exists(key)
        if is_key:
            # 判断当前key下是否有hash_key
            is_hash_key = redis_db.hexists(key, hash_key)
            if is_hash_key:
                ret_data = redis_db.hget(key, hash_key)
                if ret_data:
                    print u'从redis中获取数据'
                    return json.loads(ret_data)
        print u'从数据库中获取并写入到redis'
        ret_data = func(*args, **kwargs)
        redis_db.hset(key, hash_key, json.dumps(ret_data))
        return ret_data
    return _wrapped
return _decorator
</code></pre>

<p>@redis_cache(host=&lsquo;127.0.0.1&rsquo;, port=6379, db=0, password=&lsquo;N6MXWf&rsquo;)
def get_data_from_redis_or_db(key, hash_key):</p>

<pre><code>'''
获取数据
'''
ret_data = {
    "username":"dashan",
    "datetime":"20141024"
}
return ret_data
</code></pre>

<p>def main():</p>

<pre><code>key = 'dashan_hash'
hash_key = '20141024'
print get_data_from_redis_or_db(key, hash_key)
</code></pre>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:</p>

<pre><code>main()
</code></pre>

<p>```</p>

<h3>3.5. 另外一个装饰器的使用场景</h3>

<p>tornado中的用户认证模块
```
class MessageNewHandler(BaseHandler,MessageMixin):</p>

<pre><code>@tornado.web.authenticated
def post(self):
    user  = self.get_current_user()
    message = {
            "id":str(uuid.uuid4()),
            "current_user":user.id,
            'up':0,
    }
</code></pre>

<p><code>
上面代码表示在执行post方法之前必须经过用户登录认证，认证通过后才可以正常执行该方法。
看看tornado.web.authenticated 是怎么实现的：
</code>
def authenticated(method):</p>

<pre><code>"""Decorate methods with this to require that the user be logged in."""
@functools.wraps(method)
def wrapper(self, *args, **kwargs):
    if not self.current_user:
        if self.request.method in ("GET", "HEAD"):
            url = self.get_login_url()
            if "?" not in url:
                if urlparse.urlsplit(url).scheme:
                    # if login url is absolute, make next absolute too
                    next_url = self.request.full_url()
                else:
                    next_url = self.request.uri
                url += "?" + urllib.urlencode(dict(next=next_url))
            self.redirect(url)
            return
        raise HTTPError(403)
    return method(self, *args, **kwargs)
return wrapper
</code></pre>

<p>```</p>

<hr />

<p>简单讲一下 functools.wraps 这个修饰器的作用：
functools 这个工具提供了三个函数：partial ,update_wrapper,wraps ,而wraps 只是对 update_wrapper进行了封装一下而已。</p>

<p>在修饰器
```
def myDeco(func)</p>

<pre><code>return func
</code></pre>

<p>```
这一句中，func 实际上已经丢掉了原func 的几个属性：<strong>name</strong>、<strong>module</strong>、<strong>doc</strong>和 <strong>dict</strong>，所以，返回后的函数你无法再使用  func.<strong>doc</strong>  来获得注释内容 ，而如果改成这样：</p>

<p>```
def myDeco(func):</p>

<pre><code>@functools.wraps(func)

def _myDeco(*args,**kwargs):

    return func(*args,**kwargs)

return _myDeco
</code></pre>

<p>```
则 functools.wraps 会帮你重新绑定在返回的新函数上。</p>

<hr />

<p>说回到tornado 的例子，看它是怎么做认证 预处理的。</p>

<p>首先是：
<code>
if not self.current_user
</code>
判断是否当前用户(self.current_user是tornado的内置变量，保存当前登录的用户），如果不是，则抛出错误：</p>

<p><code>
raise HTTPError(403)
</code>
否则就返回:
<code>
return method(self, *args, **kwargs)
</code>
表示认证成功，开发者可以继续对认证成功的用户做应该做的动作。</p>
]]></content>
  </entry>
  
</feed>
